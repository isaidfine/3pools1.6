import React, { useState, useEffect, useMemo, useRef } from 'react';
import { RefreshCw, Package, Trophy, RotateCcw, AlertCircle, X, Check, Star, Hand, ArrowLeftRight, ChevronsUp, Sparkles, Layers, Send, Coins, Ticket, Trash2, Ban, Gift, Target, Shuffle, Repeat, Settings, Download, Upload, Save, FileJson, Power, Info, MousePointerClick, Crown, ListOrdered, Flag, FastForward, Zap, ShieldCheck, Clover, TrendingUp, ShoppingBag, Clock, Briefcase, Gem, Scale, Hammer, ArrowRight, Eye, Lock, ZapOff } from 'lucide-react';

// æ‰‹åŠ¨å®šä¹‰åˆ«å
const ResetIcon = RotateCcw;

// --- é˜¶æ®µé…ç½®å®šä¹‰ ---
// id: 0 -> Stage 1 (çº¯å‡€æ—¶ä»£)
// id: 1 -> Stage 2 (åˆè¯†ä»·å€¼) - æ­¤æ—¶è§£é”åˆæˆ
// id: 2 -> Stage 3 (é£é™©å¼•å…¥)
// id: 3 -> Stage 4 (ç­–ç•¥å®Œå…¨ä½“) - æ­¤æ—¶è§£é”åˆ·æ–°
const INITIAL_STAGE_CONFIG = [
  {
    id: 0,
    name: 'çº¯å‡€æ—¶ä»£',
    desc: 'The Fruit Age',
    inventorySize: 6,
    orderSlots: 2,
    poolSize: 3,
    allowedPoolCount: 3, 
    fixedPrice: 1, 
    orderCountRange: [2, 2], 
    rarityWeights: { common: 1.0, uncommon: 0, rare: 0, epic: 0, legendary: 0 },
    mechanics: { refresh: false, affixes: false, synthesis: false, variablePrice: false },
    unlocks: ["æ¸¸æˆå¼€å§‹ï¼", "è§£é”æ± å­ï¼šæ°´æœã€è¯ç‰©ã€æ–‡å…·"]
  },
  {
    id: 1,
    name: 'åˆè¯†ä»·å€¼',
    desc: 'The Medicine Age',
    inventorySize: 7,
    orderSlots: 3,
    poolSize: 4,
    allowedPoolCount: 4, 
    fixedPrice: 1,
    orderCountRange: [2, 3], 
    rarityWeights: { common: 0.5, uncommon: 0.5, rare: 0, epic: 0, legendary: 0 },
    // å˜æ›´ç¡®è®¤ï¼šè§£é”åˆæˆï¼Œæ— åˆ·æ–°
    mechanics: { refresh: false, affixes: false, synthesis: true, variablePrice: false },
    unlocks: ["è§£é”æ–°æ± å­ï¼šå¨å…·", "æ–°æœºåˆ¶ï¼šç‰©å“åˆæˆ (é™ä¼˜ç§€å“è´¨)", "ç‰©å“å“è´¨ï¼šã€ä¼˜ç§€ã€‘(ç»¿è‰²) å¼€æ”¾æ‰è½", "èƒŒåŒ…æ ä½ +1", "è®¢å•æ ä½ +1"]
  },
  {
    id: 2,
    name: 'é£é™©å¼•å…¥',
    desc: 'The Stationery Age',
    inventorySize: 8,
    orderSlots: 3,
    poolSize: 5,
    allowedPoolCount: 5, 
    fixedPrice: null, 
    orderCountRange: [2, 3], 
    rarityWeights: { common: 0.5, uncommon: 0.3, rare: 0.2, epic: 0, legendary: 0 },
    // å˜æ›´ç¡®è®¤ï¼šæ— åˆ·æ–°ï¼Œåˆæˆä¸Šé™è‡³Rare
    mechanics: { refresh: false, affixes: true, synthesis: true, variablePrice: true },
    unlocks: ["è§£é”æ–°æ± å­ï¼šç”µå™¨ (å…¨è§£é”)", "æ–°æœºåˆ¶ï¼šå¥–æ± è¯ç¼€", "æ–°æœºåˆ¶ï¼šä»·æ ¼æ³¢åŠ¨", "ç‰©å“å“è´¨ï¼šã€ç¨€æœ‰ã€‘(è“è‰²) å¼€æ”¾æ‰è½", "åˆæˆä¸Šé™æå‡è‡³è“è‰²", "èƒŒåŒ…æ ä½ +1", "æŠ€èƒ½æ± æ–°å¢ï¼šç²¾æ‰“ç»†ç®—ã€è´µå®¾æŠ˜æ‰£"]
  },
  {
    id: 3,
    name: 'ç­–ç•¥å®Œå…¨ä½“',
    desc: 'The Kitchenware Age',
    inventorySize: 9,
    orderSlots: 4,
    poolSize: 5,
    allowedPoolCount: 5,
    fixedPrice: null,
    orderCountRange: [3, 4], 
    rarityWeights: { common: 0.4, uncommon: 0.3, rare: 0.2, epic: 0.1, legendary: 0 },
    // å˜æ›´ç¡®è®¤ï¼šè§£é”åˆ·æ–°
    mechanics: { refresh: true, affixes: true, synthesis: true, variablePrice: true },
    unlocks: ["æ–°æœºåˆ¶ï¼šè®¢å•åˆ·æ–°", "ç‰©å“å“è´¨ï¼šã€å²è¯—ã€‘(ç´«è‰²) å¼€æ”¾æ‰è½", "èƒŒåŒ…æ ä½ +1", "è®¢å•æ ä½ +1", "æŠ€èƒ½æ± æ–°å¢ï¼šå›°éš¾è®¢å•ä¸“å®¶ã€åˆ·æ–°ç±»æŠ€èƒ½"]
  },
  {
    id: 4,
    name: 'å·…å³°æŒ‘æˆ˜',
    desc: 'The Electronics Age',
    inventorySize: 10,
    orderSlots: 4,
    poolSize: 5,
    allowedPoolCount: 5,
    fixedPrice: null,
    orderCountRange: [3, 4], 
    rarityWeights: { common: 0.35, uncommon: 0.3, rare: 0.2, epic: 0.15, legendary: 0.05 }, 
    mechanics: { refresh: true, affixes: true, synthesis: true, variablePrice: true },
    unlocks: ["ç»ˆææŒ‘æˆ˜å¼€å§‹", "æ›´é«˜éš¾åº¦çš„è®¢å•éœ€æ±‚", "èƒŒåŒ…æ ä½ +1"]
  }
];

// --- æŠ€èƒ½å®šä¹‰ ---
const SKILL_DEFINITIONS = [
  { id: 'poverty_relief', name: 'è´«å›°æ•‘æµ', desc: 'æŒæœ‰é‡‘å¸ < 5 æ—¶ï¼Œå®Œæˆè®¢å•çš„é‡‘å¸å¥–åŠ±é¢å¤– +10ã€‚', Icon: Gift, type: 'gold', color: 'text-yellow-600 bg-yellow-100' }, 
  { id: 'lucky_7', name: 'å¹¸è¿ 7', desc: 'å½“å‰é‡‘å¸æ•°é‡çš„å°¾æ•°ä¸º 7 æ—¶ï¼ŒæŠ½å–ä¼ è¯´ç‰©å“çš„æ¦‚ç‡ç¿»å€ã€‚', Icon: Star, type: 'luck', color: 'text-green-600 bg-green-100' }, 
  { id: 'calculated', name: 'ç²¾æ‰“ç»†ç®—', desc: 'å½“å‰é‡‘å¸ < 10 æ—¶ï¼Œæ™®é€šæŠ½å¥–çš„é‡‘å¸æ¶ˆè€— -2ï¼ˆæœ€ä½ä¸º1ï¼‰ã€‚', Icon: Coins, type: 'gold', color: 'text-blue-600 bg-blue-100' }, 
  { id: 'alchemy', name: 'ç‚¼é‡‘æœ¯', desc: 'å›æ”¶â€œç¨€æœ‰â€åŠä»¥ä¸Šå“è´¨ç‰©å“æ—¶ï¼Œ15% æ¦‚ç‡è·å¾— 5 å¼ å¥–åˆ¸ã€‚', Icon: Sparkles, type: 'recycle', color: 'text-purple-600 bg-purple-100' }, 
  { id: 'vip_discount', name: 'è´µå®¾æŠ˜æ‰£', desc: 'â€œç²¾å‡†â€å’Œâ€œæœ‰çš„æ”¾çŸ¢â€è¯ç¼€çš„å¥–æ± é‡‘å¸æ¶ˆè€—å‡å°‘ 1ã€‚', Icon: Ticket, type: 'draw', color: 'text-orange-600 bg-orange-100' },
  { id: 'negotiator', name: 'è°ˆåˆ¤ä¸“å®¶', desc: 'æŠ½åˆ°â€œå²è¯—â€æˆ–ä»¥ä¸Šå“è´¨ç‰©å“æ—¶ï¼Œæ‰€æœ‰è®¢å•è·å¾— 1 æ¬¡åˆ·æ–°æ¬¡æ•°ã€‚', Icon: ArrowLeftRight, type: 'utility', color: 'text-slate-600 bg-slate-100' }, 
  { id: 'consolation_prize', name: 'å®‰æ…°å¥–', desc: 'è¿ç»­æŠ½åˆ° 5 ä¸ªâ€œæ™®é€šâ€å“è´¨ç‰©å“åï¼Œä¸‹æ¬¡æŠ½å¥–è·å¾—çš„ç‰©å“å¿…å®šæ˜¯ç¨€æœ‰ä»¥ä¸Šå“è´¨ã€‚', Icon: Check, type: 'luck', color: 'text-teal-600 bg-teal-100' }, 
  { id: 'cut_corners', name: 'å·å·¥å‡æ–™', desc: 'åˆ·æ–°å‡ºæ–°è®¢å•æ—¶ï¼Œ20% æ¦‚ç‡ä½¿è®¢å•éœ€æ±‚ç‰©å“æ•°é‡ -1ï¼ˆæœ€ä½ä¸º1ï¼‰ã€‚', Icon: Zap, type: 'refresh', color: 'text-red-600 bg-red-100' }, 
  { id: 'time_freeze', name: 'æ—¶é—´å†»ç»“', desc: 'åˆ·æ–°å•ä¸ªè®¢å•æ—¶ï¼Œ20% æ¦‚ç‡ä¸æ¶ˆè€—è¯¥è®¢å•çš„å‰©ä½™åˆ·æ–°æ¬¡æ•°ã€‚', Icon: Clock, type: 'refresh', color: 'text-cyan-600 bg-cyan-100' },
  { id: 'ocd', name: 'å¼ºè¿«ç—‡', desc: 'æäº¤çš„è®¢å•è‹¥æ‰€æœ‰ç‰©å“å±äºåŒä¸€ç§ç±»ï¼Œé‡‘å¸/å¥–åˆ¸å¥–åŠ±ç¿»å€ã€‚', Icon: ListOrdered, type: 'order', color: 'text-indigo-600 bg-indigo-100' },
  { id: 'auto_restock', name: 'è‡ªåŠ¨è¡¥è´§', desc: 'å®Œæˆä»»æ„è®¢å•åï¼Œä¸‹æ¬¡æŠ½å¥–è·å¾—çš„ç‰©å“ä¼šå¤šè·å¾— 1 ä¸ªã€‚', Icon: Package, type: 'draw', color: 'text-lime-600 bg-lime-100' }, 
  { id: 'turn_fortune', name: 'æ—¶æ¥è¿è½¬', desc: 'å®Œæˆä»»æ„è®¢å•åï¼Œä¸‹æ¬¡æŠ½å¥–è·å¾—çš„ç‰©å“å¿…å®šæ˜¯ç¨€æœ‰ä»¥ä¸Šå“è´¨ã€‚', Icon: ChevronsUp, type: 'luck', color: 'text-rose-600 bg-rose-100' }, 
  { id: 'big_order_expert', name: 'å¤§è®¢å•ä¸“å®¶', desc: 'å®Œæˆéœ€æ±‚ç‰©å“æ•°ä¸º 4 ä¸ªçš„è®¢å•æ—¶ï¼Œé¢å¤–è·å¾— 10 å¼ å¥–åˆ¸ã€‚', Icon: Package, type: 'order', color: 'text-amber-600 bg-amber-100' },
  { id: 'hard_order_expert', name: 'å›°éš¾è®¢å•ä¸“å®¶', desc: 'å®Œæˆéœ€è¦å²è¯—ä»¥ä¸Šå“è´¨ç‰©å“çš„è®¢å•æ—¶ï¼Œé¢å¤–è·å¾— 15 å¼ å¥–åˆ¸ã€‚', Icon: Trophy, type: 'order', color: 'text-fuchsia-600 bg-fuchsia-100' },
];

// --- åˆå§‹æ•°æ®å®šä¹‰ ---

const INITIAL_AFFIXES_CONFIG = [
  { id: 'trade_in', name: 'ä»¥æ—§æ¢æ–°çš„', desc: 'ç”¨èƒŒåŒ…å†…çš„ 1 ä¸ªç‰©å“éšæœºç½®æ¢ 1 ä¸ªåŒå“è´¨çš„ç‰©å“ã€‚', type: 'interaction', weight: 10, cost: 1 },
  { id: 'hardened', name: 'ç¡¬åŒ–çš„', desc: 'ç¨€æœ‰åº¦æ›´é«˜ï¼Œä½†ç‰©å“å¸¦æœ‰ã€ç»è‚²ã€‘æ•ˆæœï¼Œæ— æ³•åˆæˆã€‚', type: 'passive', weight: 10, cost: 2 },
  { id: 'purified', name: 'æçº¯çš„', desc: 'ä¿åº•äº§å‡ºç¨€æœ‰ã€å²è¯—æˆ–ä¼ è¯´ç‰©å“ã€‚', type: 'passive', weight: 10, cost: 3 },
  { id: 'volatile', name: 'æ³¢åŠ¨çš„', desc: 'æœ‰æ›´é«˜çš„æ¦‚ç‡å‡ºç°ä¼ è¯´ç‰©å“ï¼Œä½†åªä¼šäº§å‡ºæ™®é€šå’Œä¼ è¯´ç‰©å“', type: 'passive', weight: 10, cost: 1 },
  { id: 'fragmented', name: 'ç¨€ç¢çš„', desc: 'ä¸€æ¬¡æŠ½å–è·å¾— 3 ä¸ªç‰©å“ï¼Œä½†å¿…å®šä¸ºæ™®é€šå“è´¨ã€‚', type: 'passive', weight: 10, cost: 1 },
  { id: 'precise', name: 'ç²¾å‡†çš„', desc: 'ä» 2 ä¸ªä¸åŒçš„å€™é€‰ç‰©å“ä¸­ä»»é€‰å…¶ä¸€ã€‚', type: 'interaction', weight: 10, cost: 2 },
  { id: 'targeted', name: 'æœ‰çš„æ”¾çŸ¢çš„', desc: 'æŒ‡å®šä¸€ä¸ªæƒ³è¦çš„ç‰©å“ç±»å‹ã€‚', type: 'interaction', weight: 10, cost: 4 },
];

const INITIAL_RARITY_CONFIG = [
  { id: 'common', name: 'æ™®é€š', color: 'border-slate-300 bg-slate-50 text-slate-600', dotColor: 'bg-slate-400', bonus: 0, prob: 0.40, shadow: '', starColor: 'text-slate-400', recycleValue: 0 },
  { id: 'uncommon', name: 'ä¼˜ç§€', color: 'border-green-400 bg-green-50 text-green-700', dotColor: 'bg-green-500', bonus: 0.1, prob: 0.30, shadow: 'shadow-green-200', starColor: 'text-green-500', recycleValue: 0 },
  { id: 'rare', name: 'ç¨€æœ‰', color: 'border-blue-400 bg-blue-50 text-blue-700', dotColor: 'bg-blue-500', bonus: 0.2, prob: 0.19, shadow: 'shadow-blue-200', starColor: 'text-blue-500', recycleValue: 1 },
  { id: 'epic', name: 'å²è¯—', color: 'border-purple-400 bg-purple-50 text-purple-700', dotColor: 'bg-purple-500', bonus: 0.4, prob: 0.10, shadow: 'shadow-purple-200', starColor: 'text-purple-500', recycleValue: 2 },
  { id: 'legendary', name: 'ä¼ è¯´', color: 'border-orange-400 bg-orange-50 text-orange-700', dotColor: 'bg-orange-500', bonus: 1.0, prob: 0.01, shadow: 'shadow-orange-200', starColor: 'text-orange-500', recycleValue: 4 }, 
  { id: 'mythic', name: 'ç¥è¯', color: 'border-rose-500 bg-rose-50 text-rose-700', dotColor: 'bg-rose-500', bonus: 3.0, prob: 0, shadow: 'shadow-rose-200', starColor: 'text-rose-600', recycleValue: 10 },
];

const INITIAL_POOLS_DATA = [
  {
    id: 'fruit', name: 'æ°´æœ', type: 'normal', weight: 4, currency: 'gold',
    color: 'bg-green-100 text-green-800 border-green-200', icon: 'ğŸ',
    items: [{ name: 'è¥¿ç“œ', icon: 'ğŸ‰' }, { name: 'æŸ æª¬', icon: 'ğŸ‹' }, { name: 'èŠ’æœ', icon: 'ğŸ¥­' }, { name: 'è‹¹æœ', icon: 'ğŸ' }, { name: 'æ©™å­', icon: 'ğŸŠ' }]
  },
  {
    id: 'medicine', name: 'è¯ç‰©', type: 'normal', weight: 4, currency: 'gold',
    color: 'bg-red-100 text-red-800 border-red-200', icon: 'ğŸ’Š',
    items: [{ name: 'å†²å‰‚', icon: 'ğŸµ' }, { name: 'æ»´çœ¼æ¶²', icon: 'ğŸ’§' }, { name: 'æ³¨å°„å™¨', icon: 'ğŸ’‰' }, { name: 'èƒ¶å›Š', icon: 'ğŸ’Š' }, { name: 'ç»·å¸¦', icon: 'ğŸ¤•' }]
  },
  {
    id: 'stationery', name: 'æ–‡å…·', type: 'normal', weight: 4, currency: 'gold',
    color: 'bg-yellow-100 text-yellow-800 border-yellow-200', icon: 'âœï¸',
    items: [{ name: 'é“…ç¬”', icon: 'âœï¸' }, { name: 'æ©¡çš®', icon: 'ğŸ§¼' }, { name: 'è®¢ä¹¦æœº', icon: 'ğŸ“' }, { name: 'ç¬”è®°æœ¬', icon: 'ğŸ“’' }, { name: 'å°ºå­', icon: 'ğŸ“' }]
  },
  {
    id: 'kitchenware', name: 'å¨å…·', type: 'normal', weight: 4, currency: 'gold',
    color: 'bg-orange-100 text-orange-800 border-orange-200', icon: 'ğŸ³',
    items: [{ name: 'å¹³åº•é”…', icon: 'ğŸ³' }, { name: 'èœåˆ€', icon: 'ğŸ”ª' }, { name: 'ç §æ¿', icon: 'ğŸªµ' }, { name: 'æ±¤å‹º', icon: 'ğŸ¥„' }, { name: 'å‰å­', icon: 'ğŸ´' }]
  },
  {
    id: 'electronics', name: 'ç”µå™¨', type: 'normal', weight: 4, currency: 'gold',
    color: 'bg-blue-100 text-blue-800 border-blue-200', icon: 'âš¡ï¸',
    items: [{ name: 'æ‰‹æœº', icon: 'ğŸ“±' }, { name: 'è€³æœº', icon: 'ğŸ§' }, { name: 'ç©ºè°ƒ', icon: 'â„ï¸' }, { name: 'ç”µè„‘', icon: 'ğŸ’»' }, { name: 'ç”µè§†', icon: 'ğŸ“º' }]
  }
];

const MAINLINE_ITEMS = [
  { id: 'm1', name: 'ä»™æœ', icon: 'ğŸ‘', poolId: 'fruit', desc: 'ä¸»çº¿1é“å…·' },
  { id: 'm2', name: 'çµä¸¹', icon: 'ğŸº', poolId: 'medicine', desc: 'ä¸»çº¿2é“å…·' },
  { id: 'm3', name: 'ç¥ç¬”', icon: 'ğŸ–Œï¸', poolId: 'stationery', desc: 'ä¸»çº¿3é“å…·' },
  { id: 'm4', name: 'é‡‘é“²é“²', icon: 'ğŸ”±', poolId: 'kitchenware', desc: 'ä¸»çº¿4é“å…·' },
  { id: 'm5', name: 'ç‰¹æ–¯æ‹‰', icon: 'ğŸš˜', poolId: 'electronics', desc: 'ä¸»çº¿5é“å…·' },
];

const INITIAL_GAME_CONFIG = {
  affixes: INITIAL_AFFIXES_CONFIG,
  rarity: INITIAL_RARITY_CONFIG,
  pools: INITIAL_POOLS_DATA,
  stages: INITIAL_STAGE_CONFIG, // æ–°å¢ï¼šå°†é˜¶æ®µé…ç½®çº³å…¥æ€»é…ç½®
  enabledSkillIds: SKILL_DEFINITIONS.map(s => s.id), 
  global: {
    refreshCost: 5,
    initialGold: 30,
    initialTickets: 0,
    mainlineChance: 0.5,
    mainlineDropRate: 0.3,
    mainlineFillerLegendaryRate: 0.1,
  }
};

// --- çº¯é€»è¾‘å‡½æ•° ---

const getAllNormalItems = (pools, currentStageConfig) => {
  // ä¿®æ­£ï¼šé™åˆ¶æ± å­ç±»å‹ï¼ˆallowedPoolCountï¼‰å’Œæ± å†…ç‰©å“æ•°é‡ï¼ˆpoolSizeï¼‰
  const allowedPools = pools.slice(0, currentStageConfig.allowedPoolCount);
  
  return allowedPools.flatMap(pool => 
    pool.items.slice(0, currentStageConfig.poolSize).map(item => ({ ...item, poolId: pool.id, poolName: pool.name }))
  );
};

const getRandomAffix = (affixes) => {
  const totalWeight = affixes.reduce((sum, a) => sum + (a.weight || 0), 0);
  let r = Math.random() * totalWeight;
  for (const affix of affixes) {
    r -= affix.weight || 0;
    if (r <= 0) {
      return affix;
    }
  }
  return affixes[0];
};

const getRandomItems = (array, count) => {
  const shuffled = [...array].sort(() => 0.5 - Math.random());
  return shuffled.slice(0, count);
};

const rollRequirementRarity = (config, currentStageConfig) => {
  const weights = currentStageConfig.rarityWeights;
  const r = Math.random();
  
  // ç´¯ç§¯æ¦‚ç‡è®¡ç®—
  let accumulated = 0;
  
  // å¼ºåˆ¶æŒ‰ç…§ weights æƒé‡ Rollï¼Œå¦‚æœé˜¶æ®µæ²¡æœ‰é…ç½®è¯¥ç¨€æœ‰åº¦æƒé‡ï¼Œåˆ™ä¸ä¼š Roll å‡ºæ¥
  if (weights.common > 0) {
      accumulated += weights.common;
      if (r <= accumulated) return config.rarity.find(r => r.id === 'common');
  }
  if (weights.uncommon > 0) {
      accumulated += weights.uncommon;
      if (r <= accumulated) return config.rarity.find(r => r.id === 'uncommon');
  }
  if (weights.rare > 0) {
      accumulated += weights.rare;
      if (r <= accumulated) return config.rarity.find(r => r.id === 'rare');
  }
  if (weights.epic > 0) {
      accumulated += weights.epic;
      if (r <= accumulated) return config.rarity.find(r => r.id === 'epic');
  }
  
  // Fallback to common
  return config.rarity.find(r => r.id === 'common');
};

const generateOrder = (allNormalItems, config, hasSkill = () => false, currentStageConfig) => {
  const { orderCountRange } = currentStageConfig;
  const rand = Math.random();
  let count = orderCountRange[0]; 
  
  // ç®€å•çš„åŠ æƒè®¡ç®—æ•°é‡
  if (orderCountRange[1] > orderCountRange[0]) {
      if (currentStageConfig.id === 1) { // Stage 2
          count = rand < 0.5 ? 2 : 3;
      } else if (currentStageConfig.id === 2) { // Stage 3
          count = rand < 0.3 ? 2 : 3;
      } else if (currentStageConfig.id === 3) { // Stage 4
          count = rand < 0.8 ? 3 : 4;
      } else if (currentStageConfig.id === 4) { // Stage 5
          count = rand < 0.6 ? 3 : 4;
      }
  }

  // æŠ€èƒ½ã€å·å·¥å‡æ–™ã€‘
  if (hasSkill('cut_corners') && Math.random() < 0.20 && count > 1) {
      count -= 1;
  }

  const rawRequirements = getRandomItems(allNormalItems, count);
  
  const requirements = rawRequirements.map(item => ({
    ...item,
    requiredRarity: rollRequirementRarity(config, currentStageConfig)
  }));

  const totalReqBonus = requirements.reduce((sum, req) => sum + req.requiredRarity.bonus, 0);
  
  // å…ˆç¡®å®šå¥–åŠ±ç±»å‹ï¼Œå†æ ¹æ®æ•°é‡åˆ†é…å¯¹åº”çš„åŸºç¡€å€¼
  const rewardType = Math.random() < 0.5 ? 'gold' : 'ticket';
  let rawBaseReward = 0;

  if (count <= 2) {
      rawBaseReward = rewardType === 'gold' ? 5 : 10;
  } else if (count === 3) {
      rawBaseReward = rewardType === 'gold' ? 10 : 20;
  } else {
      rawBaseReward = rewardType === 'gold' ? 15 : 30;
  }

  const baseReward = Math.ceil(rawBaseReward * (1 + totalReqBonus));

  return {
    id: Math.random().toString(36).substr(2, 9),
    requirements,
    baseReward,
    rewardType, 
    remainingRefreshes: 2,
    isMainline: false
  };
};

const generateMainlineOrder = (level, config, currentStageConfig) => {
  if (level >= MAINLINE_ITEMS.length) return null;

  const targetMainlineItem = MAINLINE_ITEMS[level];
  const targetPool = config.pools.find(p => p.id === targetMainlineItem.poolId);
  
  // ä¿®æ­£ï¼šç¡®ä¿ä¸»çº¿éœ€æ±‚çš„ç‰©å“å­˜åœ¨äºè¢«æˆªæ–­çš„å¥–æ± ä¸­ï¼Œä¸”æ± å­ç±»å‹ä¹Ÿæ˜¯å·²è§£é”çš„
  const availableItems = targetPool.items.slice(0, currentStageConfig.poolSize);
  const randomItem = availableItems[Math.floor(Math.random() * availableItems.length)];

  // æ ¹æ®é˜¶æ®µè®¾ç½®ä¸»çº¿éœ€æ±‚çš„ç¨€æœ‰åº¦
  const mainlineFillerRarities = ['common', 'uncommon', 'rare', 'epic', 'legendary'];
  const targetRarityId = mainlineFillerRarities[level] || 'common';
  const fillerRarity = config.rarity.find(r => r.id === targetRarityId);
  const mythicRarity = config.rarity.find(r => r.id === 'mythic');

  const req1 = {
     ...targetMainlineItem,
     requiredRarity: mythicRarity,
     isMainlineItem: true
  };

  const req2 = {
     ...randomItem,
     poolId: targetPool.id,
     poolName: targetPool.name,
     requiredRarity: fillerRarity
  };

  return {
    id: `mainline_order_${level}`,
    requirements: [req1, req2],
    baseReward: 0,
    rewardType: 'none',
    remainingRefreshes: 0,
    isMainline: true,
    level: level + 1,
    name: `ä¸»çº¿è¿›åº¦ ${level + 1}/5`
  };
};

const rollRarity = (config, affixKey = null, currentGold = 0, hasSkill = () => false, skillState = {}, currentStageConfig) => {
  const { rarity: rarityConfig } = config;
  const weights = currentStageConfig.rarityWeights;

  // æ£€æŸ¥æŠ€èƒ½ä¿åº•
  if (skillState.nextDrawGuaranteedRare) {
      const allowedRarities = rarityConfig.filter(r => weights[r.id] > 0);
      const highRarities = allowedRarities.filter(r => ['rare', 'epic', 'legendary'].includes(r.id));
      
      if (highRarities.length > 0) {
           return highRarities[Math.floor(Math.random() * highRarities.length)];
      } else {
           return allowedRarities[allowedRarities.length - 1];
      }
  }

  // è¯ç¼€å¤„ç†
  if (affixKey === 'hardened' || affixKey === 'purified') {
      if (weights.legendary > 0) {
        const r = Math.random();
        if (r < 0.67) return rarityConfig.find(r => r.id === 'rare');
        if (r < 0.97) return rarityConfig.find(r => r.id === 'epic');
        return rarityConfig.find(r => r.id === 'legendary');
      } else if (weights.epic > 0) {
          const r = Math.random();
          return r < 0.7 ? rarityConfig.find(r => r.id === 'rare') : rarityConfig.find(r => r.id === 'epic');
      } else if (weights.rare > 0) {
          return rarityConfig.find(r => r.id === 'rare');
      }
      return rarityConfig.find(r => r.id === 'uncommon'); // Fallback
  }

  if (affixKey === 'volatile') {
    if (weights.legendary > 0) {
        const r = Math.random();
        if (r < 0.92) return rarityConfig.find(r => r.id === 'common');
        return rarityConfig.find(r => r.id === 'legendary');
    }
    return rarityConfig.find(r => r.id === 'common');
  }

  if (affixKey === 'fragmented') {
    return rarityConfig.find(r => r.id === 'common');
  }

  const r = Math.random();
  let accumulated = 0;
  
  let legendaryProbMultiplier = 1;
  if (hasSkill('lucky_7') && (currentGold % 10 === 7)) {
      legendaryProbMultiplier = 2;
  }

  // ä½¿ç”¨ Stage Config çš„æƒé‡è¿›è¡Œ Roll
  const orderedRarityIds = ['common', 'uncommon', 'rare', 'epic', 'legendary'];
  
  for (const rid of orderedRarityIds) {
      if (weights[rid] > 0) {
        let prob = weights[rid];
        if (rid === 'legendary') prob *= legendaryProbMultiplier; // è™½ç„¶æƒé‡è¡¨é‡Œæ˜¯ 0ï¼Œä½†å¦‚æœæœªæ¥é…ç½®å¼€æ”¾äº†
        accumulated += prob;
        if (r <= accumulated) {
            return rarityConfig.find(item => item.id === rid);
        }
      }
  }

  return rarityConfig[0]; 
};

const getNextRarity = (currentRarityId, config) => {
  const { rarity: rarityConfig } = config;
  const currentIndex = rarityConfig.findIndex(r => r.id === currentRarityId);
  if (currentIndex !== -1 && currentIndex < rarityConfig.length - 1) {
    return rarityConfig[currentIndex + 1];
  }
  return null;
};

// --- UI ç»„ä»¶ ---

const Toast = ({ message, type = 'info', onClose }) => {
  useEffect(() => {
    const timer = setTimeout(onClose, 2000);
    return () => clearTimeout(timer);
  }, [onClose]);

  const bgColor = type === 'error' ? 'bg-red-500' : 'bg-slate-800';
  
  return (
    <div className={`fixed top-20 left-1/2 -translate-x-1/2 z-[200] ${bgColor} text-white px-6 py-2 rounded-full shadow-lg flex items-center gap-2 animate-in slide-in-from-top-4 fade-in`}>
      {type === 'error' ? <AlertCircle size={18} /> : <Info size={18} />}
      <span className="font-bold text-sm">{message}</span>
    </div>
  );
};

const ConfirmDialog = ({ title, message, onConfirm, onCancel }) => {
  return (
    <div className="fixed inset-0 z-[200] flex items-center justify-center bg-black/60 backdrop-blur-sm animate-in fade-in">
      <div className="bg-white p-6 rounded-2xl shadow-2xl max-w-sm w-full mx-4 animate-in zoom-in-95">
        <h3 className="text-xl font-black text-slate-800 mb-2">{title}</h3>
        <p className="text-slate-600 mb-6">{message}</p>
        <div className="flex gap-3 justify-end">
          <button 
            onClick={onCancel}
            className="px-4 py-2 rounded-lg font-bold text-slate-500 hover:bg-slate-100"
          >
            å–æ¶ˆ
          </button>
          <button 
            onClick={onConfirm}
            className="px-6 py-2 rounded-lg font-bold bg-red-500 text-white hover:bg-red-600 shadow-md"
          >
            ç¡®è®¤
          </button>
        </div>
      </div>
    </div>
  );
};

// æŠ€èƒ½é€‰æ‹©/æ›¿æ¢å¼¹çª—
const SkillSelectionModal = ({ candidates, onSelect, currentSkills, onReplace }) => {
    const isReplacing = currentSkills && currentSkills.length >= 3;
    const [selectedCandidate, setSelectedCandidate] = useState(null);
    const [targetOldSkillId, setTargetOldSkillId] = useState(null); 
    const [isPeeking, setIsPeeking] = useState(false); // å·çœ‹çŠ¶æ€

    return (
        <div className={`fixed inset-0 z-[200] flex items-center justify-center transition-colors duration-200 ${isPeeking ? 'bg-transparent' : 'bg-black/80 backdrop-blur-md'}`}>
            {/* å·çœ‹æŒ‰é’® - å§‹ç»ˆå¯è§ */}
            <button
                className="absolute top-4 right-4 z-[210] bg-white text-slate-800 p-3 rounded-full shadow-lg font-bold flex items-center gap-2 hover:bg-slate-100 active:scale-95 transition-all cursor-pointer ring-2 ring-slate-200"
                onMouseDown={() => setIsPeeking(true)}
                onMouseUp={() => setIsPeeking(false)}
                onMouseLeave={() => setIsPeeking(false)}
                onTouchStart={() => setIsPeeking(true)}
                onTouchEnd={() => setIsPeeking(false)}
                title="æŒ‰ä½æŸ¥çœ‹åº•éƒ¨å†…å®¹"
            >
                <Eye size={20} />
                <span className="hidden md:inline">æŒ‰ä½æŸ¥çœ‹</span>
            </button>

            {/* å¼¹çª—ä¸»ä½“ - å·çœ‹æ—¶éšè— */}
            <div className={`w-full max-w-5xl p-6 lg:p-8 flex flex-col items-center h-[90vh] overflow-y-auto transition-opacity duration-200 ${isPeeking ? 'opacity-0 pointer-events-none' : 'opacity-100'}`}>
                <h2 className="text-3xl font-black text-white mb-2 tracking-wider uppercase">
                    {isReplacing ? "æŠ€èƒ½æ§½å·²æ»¡ï¼" : "é€‰æ‹©ä¸€ä¸ªæŠ€èƒ½"}
                </h2>
                <p className="text-slate-300 mb-8 font-bold text-center">
                    {isReplacing ? "è¯·åˆ†åˆ«é€‰æ‹©ä¸€ä¸ªã€æ–°æŠ€èƒ½ã€‘å’Œä¸€ä¸ªã€æ—§æŠ€èƒ½ã€‘è¿›è¡Œæ›¿æ¢" : "ä¸»çº¿ä»»åŠ¡å¥–åŠ±"}
                </p>

                <div className="flex flex-col gap-8 w-full">
                    {/* æ–°æŠ€èƒ½å€™é€‰åŒº */}
                    <div className="w-full">
                        <div className="text-sm font-bold text-slate-400 uppercase tracking-widest mb-4 flex items-center gap-2">
                             <Sparkles size={16} /> æ–°æŠ€èƒ½å€™é€‰ (ç‚¹å‡»é€‰æ‹©)
                        </div>
                        <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
                             {candidates.map((skill) => {
                                // Safe render for Icon
                                const SkillIcon = skill.Icon || Zap;
                                return (
                                <button
                                    key={skill.id}
                                    onClick={() => {
                                        if (!isReplacing) onSelect(skill);
                                        else setSelectedCandidate(skill);
                                    }}
                                    className={`
                                        bg-white rounded-2xl p-6 flex flex-col items-center gap-3 transition-all duration-200 relative group
                                        ${!isReplacing ? 'hover:scale-105 hover:shadow-2xl cursor-pointer' : ''}
                                        ${isReplacing && selectedCandidate?.id === skill.id ? 'ring-4 ring-green-500 scale-105 shadow-xl bg-green-50' : 'opacity-90 hover:opacity-100'}
                                    `}
                                >
                                    {isReplacing && selectedCandidate?.id === skill.id && (
                                        <div className="absolute -top-3 -right-3 bg-green-500 text-white px-3 py-1 rounded-full font-black text-xs shadow-lg z-10 flex items-center gap-1">
                                            <Check size={12}/> å­¦ä¹ 
                                        </div>
                                    )}
                                    <div className={`w-14 h-14 rounded-full ${skill.color} flex items-center justify-center shadow-inner`}>
                                        <SkillIcon size={28} />
                                    </div>
                                    <div className="text-center">
                                        <h3 className="text-lg font-bold text-slate-800">{skill.name}</h3>
                                        <p className="text-xs text-slate-500 leading-relaxed mt-1">{skill.desc}</p>
                                    </div>
                                    {!isReplacing && <span className="mt-2 text-xs font-bold text-blue-500 uppercase tracking-wider opacity-0 group-hover:opacity-100 transition-opacity">ç‚¹å‡»è·å–</span>}
                                </button>
                            )})}
                        </div>
                    </div>

                    {/* æ—§æŠ€èƒ½åŒº (æ›¿æ¢æ¨¡å¼ä¸‹ä¸ºå¯äº¤äº’ï¼Œéæ›¿æ¢æ¨¡å¼ä¸‹ä¸ºåªè¯»å±•ç¤º) */}
                    <div className="w-full p-6 rounded-3xl bg-slate-800/50 border border-slate-700">
                         <div className="text-sm font-bold text-slate-400 uppercase tracking-widest mb-4 flex items-center gap-2">
                            {isReplacing ? <><Trash2 size={16} /> é€‰æ‹©è¦é—å¿˜çš„æ—§æŠ€èƒ½</> : <><Info size={16} /> å½“å‰å·²æ‹¥æœ‰æŠ€èƒ½</>}
                         </div>
                         
                         {currentSkills.length === 0 ? (
                             <div className="text-slate-500 italic text-center py-4">æš‚æ— æŠ€èƒ½</div>
                         ) : (
                             <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
                                {currentSkills.map(skillId => {
                                    const skill = SKILL_DEFINITIONS.find(s => s.id === skillId);
                                    const SkillIcon = skill?.Icon || Zap;
                                    return (
                                        <button
                                            key={skill?.id || Math.random()}
                                            onClick={() => isReplacing && setTargetOldSkillId(skill?.id)}
                                            disabled={!isReplacing}
                                            className={`
                                                flex flex-col items-center gap-3 p-4 rounded-xl border-2 transition-all relative
                                                ${isReplacing 
                                                    ? (targetOldSkillId === skill?.id 
                                                        ? 'bg-red-500/20 border-red-500 text-white ring-2 ring-red-500 shadow-lg scale-105 cursor-pointer' 
                                                        : 'bg-slate-700 border-slate-600 text-slate-300 hover:bg-slate-600 cursor-pointer')
                                                    : 'bg-slate-700/50 border-slate-600 text-slate-400 cursor-default opacity-80' // åªè¯»æ ·å¼
                                                }
                                            `}
                                        >
                                            <div className={`w-12 h-12 rounded-full flex items-center justify-center ${skill?.color || 'bg-slate-500'} bg-opacity-90 shadow-sm`}>
                                                <SkillIcon size={24} />
                                            </div>
                                            <div className="text-center">
                                                <div className="font-bold">{skill?.name || 'æœªçŸ¥æŠ€èƒ½'}</div>
                                                <div className="text-[10px] opacity-70 mt-1">{skill?.desc}</div>
                                            </div>
                                            {isReplacing && targetOldSkillId === skill?.id && (
                                                <div className="absolute -top-2 -right-2 bg-red-500 text-white px-2 py-0.5 rounded-full font-bold text-[10px] shadow-sm">
                                                    é—å¿˜
                                                </div>
                                            )}
                                        </button>
                                    );
                                })}
                             </div>
                         )}
                    </div>
                </div>

                {/* æ“ä½œæ  */}
                <div className="mt-8 flex gap-4 w-full justify-center">
                     <button
                        onClick={() => onSelect(null)} 
                        className="px-8 py-3 rounded-full border-2 border-slate-500 text-slate-300 hover:bg-slate-700 hover:text-white transition-all font-bold uppercase tracking-wider"
                    >
                        æ”¾å¼ƒæ–°æŠ€èƒ½
                    </button>
                    
                    {isReplacing && (
                         <button
                            disabled={!selectedCandidate || !targetOldSkillId}
                            onClick={() => onReplace(targetOldSkillId, selectedCandidate)}
                            className={`
                                px-8 py-3 rounded-full font-black text-lg shadow-xl flex items-center gap-2 transition-all
                                ${selectedCandidate && targetOldSkillId 
                                    ? 'bg-gradient-to-r from-green-500 to-emerald-600 text-white hover:scale-105 hover:shadow-green-500/50' 
                                    : 'bg-slate-600 text-slate-400 cursor-not-allowed opacity-50'
                                }
                            `}
                        >
                            <span>ç¡®è®¤æ›¿æ¢</span>
                            {selectedCandidate && targetOldSkillId && <ArrowRight size={20} />}
                        </button>
                    )}
                </div>
            </div>
        </div>
    );
};

// --- æ ¸å¿ƒæ¸¸æˆç»„ä»¶ (GameCore) ---

function GameCore({ config, onOpenSettings, onReset, initialSkills = [] }) {
  const [gold, setGold] = useState(config.global.initialGold);
  const [tickets, setTickets] = useState(config.global.initialTickets);
  
  const [mainlineProgress, setMainlineProgress] = useState(0); 
  
  // ä¿®æ­£ï¼šä» config.stages è·å–é…ç½®
  const currentStageConfig = config.stages[mainlineProgress] || config.stages[config.stages.length - 1];
  const maxInventorySize = currentStageConfig.inventorySize;

  const [drawCount, setDrawCount] = useState(0);

  const [activePools, setActivePools] = useState([]);
  const [orders, setOrders] = useState([]); 
  const [mainlineOrder, setMainlineOrder] = useState(null); 

  const [inventory, setInventory] = useState([]); 
  
  const [pendingItem, setPendingItem] = useState(null);
  const [pendingQueue, setPendingQueue] = useState([]); 

  const [selectedSlot, setSelectedSlot] = useState(null);

  const [hoveredPoolId, setHoveredPoolId] = useState(null);
  const [hoveredItemName, setHoveredItemName] = useState(null);
  const [hoveredSlotIndex, setHoveredSlotIndex] = useState(null);
  
  // æ–°å¢ï¼šè®°å½•å½“å‰æ‚¬æµ®çš„å¥–æ± å†…å®é™…æœ‰çš„ç‰©å“åç§°ï¼Œç”¨äºé«˜äº®æ£€æµ‹
  const [hoveredPoolItemNames, setHoveredPoolItemNames] = useState([]);

  const [isSubmitMode, setIsSubmitMode] = useState(false);
  const [isRecycleMode, setIsRecycleMode] = useState(false); 
  const [selectedIndices, setSelectedIndices] = useState([]);

  const [modalContent, setModalContent] = useState(null);
  const [selectionMode, setSelectionMode] = useState(null); 
  
  // æŠ€èƒ½ç³»ç»ŸçŠ¶æ€
  const [skills, setSkills] = useState(initialSkills); // Store Skill IDs
  const [skillSelectionCandidates, setSkillSelectionCandidates] = useState(null);
  const [skillState, setSkillState] = useState({
      consecutiveCommons: 0,
      nextDrawGuaranteedRare: false,
      nextDrawExtraItem: false,
  });

  const [toast, setToast] = useState(null); 

  const showToast = (message, type = 'info') => {
    setToast({ message, type });
  };

  const hasSkill = (id) => skills.includes(id);

  // ä¿®æ­£ï¼šå°† currentStageConfig ä¼ å…¥ getAllNormalItemsï¼Œå¹¶åŠ å…¥ä¾èµ–æ•°ç»„
  const allNormalItems = useMemo(() => getAllNormalItems(config.pools, currentStageConfig), [config.pools, currentStageConfig]);

  // ç›‘å¬å¤–éƒ¨æ³¨å…¥çš„æŠ€èƒ½ï¼ˆå¼€å‘è€…å·¥å…·çƒ­æ›´æ–°ï¼‰
  useEffect(() => {
    // å¼€å‘è€…å·¥å…·çƒ­æ›´æ–°ï¼šç›´æ¥è¦†ç›–å½“å‰æ‰€æœ‰æŠ€èƒ½
    if (initialSkills && initialSkills.length > 0) {
        setSkills([...initialSkills]);
    }
  }, [initialSkills]);

  // ç”Ÿæˆä¸»çº¿è®¢å• (å½“è¿›åº¦å˜åŒ–æ—¶)
  useEffect(() => {
    if (mainlineProgress < 5) {
        setMainlineOrder(generateMainlineOrder(mainlineProgress, config, currentStageConfig));
    } else {
        setMainlineOrder(null); 
    }
  }, [mainlineProgress, config, currentStageConfig]); // Add currentStageConfig dep

  // åˆå§‹åŒ–è®¢å• - ä¾èµ– currentStageConfig
  useEffect(() => {
      // è¿™é‡Œçš„é€»è¾‘ç¨å¾®è°ƒæ•´ï¼šå½“é˜¶æ®µå˜åŒ–æ—¶ï¼Œå¦‚æœè®¢å•æ§½ä½å¢åŠ äº†ï¼Œè¡¥é½è®¢å•
      if (orders.length < currentStageConfig.orderSlots) {
          const needed = currentStageConfig.orderSlots - orders.length;
          const newOrders = [...orders, ...Array(needed).fill(null).map(() => generateOrder(allNormalItems, config, hasSkill, currentStageConfig))];
          setOrders(newOrders);
      } else if (orders.length === 0) {
          // åˆå§‹åŠ è½½
          setOrders(Array(currentStageConfig.orderSlots).fill(null).map(() => generateOrder(allNormalItems, config, hasSkill, currentStageConfig)));
      }
  }, [config, allNormalItems, currentStageConfig.orderSlots]); // æ³¨æ„ä¾èµ–

  // æ–°çš„å¥–æ± ç”Ÿæˆé€»è¾‘
  const generateActivePools = () => {
    const result = [];
    const usedAffixIds = new Set();
    
    // ä¿®æ­£ï¼šæ ¹æ® allowedPoolCount è¿‡æ»¤å½“å‰å¯å‡ºç°çš„æ± å­ç±»å‹
    let tempPools = config.pools.slice(0, currentStageConfig.allowedPoolCount);

    const mainlineChance = config.global.mainlineChance !== undefined ? config.global.mainlineChance : 0.5;
    const canSpawnMainline = tickets >= 10 && Math.random() < mainlineChance && mainlineProgress < 5;

    let targetMainlineItem = null;

    if (canSpawnMainline) {
        const neededItems = MAINLINE_ITEMS;
        for (let i = mainlineProgress; i < neededItems.length; i++) {
            const itemDef = neededItems[i];
            const hasItemByName = inventory.some(inv => inv.name === itemDef.name);
            if (!hasItemByName) {
                targetMainlineItem = itemDef;
                break;
            }
        }
    }

    let slotTypes = ['normal', 'normal', 'normal'];
    if (targetMainlineItem) {
        slotTypes[0] = 'mainline'; 
    }
    
    slotTypes = slotTypes.sort(() => 0.5 - Math.random());

    for (let i = 0; i < 3; i++) {
       let selectedPool = null;
       const type = slotTypes[i];

       if (type === 'mainline' && targetMainlineItem) {
           selectedPool = {
             id: `mainline_pool_${targetMainlineItem.id}_${Date.now()}`, 
             name: `${targetMainlineItem.name}æ± `, 
             type: 'mainline',
             targetItem: targetMainlineItem,
             weight: 0,
             cost: 10,
             currency: 'ticket',
             icon: targetMainlineItem.icon,
             color: 'bg-purple-100 text-purple-900 border-purple-300 ring-2 ring-purple-400',
             items: [] 
           };
           targetMainlineItem = null; 
       } else {
           if (tempPools.length > 0) {
               const totalWeight = tempPools.reduce((sum, p) => sum + p.weight, 0);
               let r = Math.random() * totalWeight;
               let selectedIndex = -1;

               for (let j = 0; j < tempPools.length; j++) {
                 r -= tempPools[j].weight;
                 if (r <= 0) {
                   selectedIndex = j;
                   break;
                 }
               }
               if (selectedIndex === -1) selectedIndex = tempPools.length - 1;

               // æ·±æ‹·è´å¹¶æˆªå– itemsï¼Œæ ¹æ® Stage Config çš„ poolSize
               selectedPool = JSON.parse(JSON.stringify(tempPools[selectedIndex]));
               selectedPool.originalId = selectedPool.id; 
               selectedPool.id = `${selectedPool.id}_${i}_${Math.random().toString(36).substr(2,5)}`;
               
               // æ ¹æ®é˜¶æ®µé™åˆ¶æ± å­å†…ç‰©å“æ•°é‡
               selectedPool.items = selectedPool.items.slice(0, currentStageConfig.poolSize);

               tempPools.splice(selectedIndex, 1);
           }
       }
       
       if (selectedPool && selectedPool.type === 'normal') {
          // ä»…å½“é˜¶æ®µæœºåˆ¶å…è®¸ affixes æ—¶æ‰æ·»åŠ è¯ç¼€
          if (currentStageConfig.mechanics.affixes) {
              const availableAffixes = config.affixes.filter(a => !usedAffixIds.has(a.id));
              const affixPool = availableAffixes.length > 0 ? availableAffixes : config.affixes;
              const affix = getRandomAffix(affixPool);
              
              selectedPool.affixKey = affix.id;
              selectedPool.affix = affix;
              selectedPool.cost = affix.cost;
              usedAffixIds.add(affix.id);
          } else {
              // é˜¶æ®µ 1-2 æ— è¯ç¼€ï¼Œé»˜è®¤ä»·æ ¼ç”±é˜¶æ®µé…ç½®å†³å®š
              selectedPool.cost = currentStageConfig.fixedPrice !== null ? currentStageConfig.fixedPrice : 1; 
          }
       }

       if (selectedPool) result.push(selectedPool);
    }
    return result;
  };

  const refreshPools = () => {
    setActivePools(generateActivePools());
  };

  useEffect(() => {
    refreshPools();
  }, [config, mainlineProgress]); // ç§»é™¤ inventory/ticketsï¼Œé˜²æ­¢æ“ä½œå¯¼è‡´åˆ·æ–°

  // --- æŠ€èƒ½è§¦å‘è¾…åŠ©å‡½æ•° ---
  const triggerSkillSelection = () => {
     // è¿‡æ»¤æ‰å·²æ‹¥æœ‰çš„æŠ€èƒ½
     // å¢åŠ é˜¶æ®µæ£€æŸ¥ï¼š
     // ç²¾æ‰“ç»†ç®—, è´µå®¾æŠ˜æ‰£ -> mainlineProgress >= 2 (å®Œæˆé˜¶æ®µ2ä»»åŠ¡ï¼Œè¿›å…¥é˜¶æ®µ3)
     // å›°éš¾è®¢å•ä¸“å®¶ -> mainlineProgress >= 3 (å®Œæˆé˜¶æ®µ3ä»»åŠ¡ï¼Œè¿›å…¥é˜¶æ®µ4)

     const availableSkills = SKILL_DEFINITIONS.filter(s => {
         if (!config.enabledSkillIds.includes(s.id)) return false;
         if (skills.includes(s.id)) return false;

         // é˜¶æ®µé”æ£€æŸ¥
         // 2025-11-25 æ›´æ–°ï¼šåˆ·æ–°ç±»æŠ€èƒ½ï¼ˆå·å·¥å‡æ–™, æ—¶é—´å†»ç»“ï¼‰æ¨è¿Ÿåˆ° Stage 4 (è¿›åº¦ >= 3)
         if ((s.id === 'calculated' || s.id === 'vip_discount') && mainlineProgress < 2) return false;
         if (s.id === 'hard_order_expert' && mainlineProgress < 3) return false;
         if ((['cut_corners', 'time_freeze', 'negotiator'].includes(s.id)) && mainlineProgress < 3) return false;
         
         return true;
     });

     if (availableSkills.length === 0) {
         showToast("æš‚æ— æ›´å¤šå¯å­¦ä¹ æŠ€èƒ½ï¼");
         return;
     }

     const candidates = getRandomItems(availableSkills, Math.min(3, availableSkills.length));
     setSkillSelectionCandidates(candidates);
  };

  const handleSkillSelect = (skill) => {
      if (!skill) {
          // Give up
          setSkillSelectionCandidates(null);
          return;
      }
      if (skills.length < 3) {
          setSkills(prev => [...prev, skill.id]);
          setSkillSelectionCandidates(null);
          showToast(`è·å¾—äº†æŠ€èƒ½ï¼š${skill.name}`);
      }
  };

  const handleSkillReplace = (oldSkillId, newSkill) => {
      setSkills(prev => prev.map(id => id === oldSkillId ? newSkill.id : id));
      setSkillSelectionCandidates(null);
      showToast(`æ›¿æ¢æŠ€èƒ½ï¼š${newSkill.name}`);
  };

  // --- ç»Ÿè®¡ä¸è®¡ç®— ---
  const maxRequirementRarityMap = useMemo(() => {
    const map = {};
    const allOrders = [...orders];
    if (mainlineOrder) allOrders.push(mainlineOrder);

    allOrders.forEach(order => {
      if (!order) return;
      order.requirements.forEach(req => {
         const currentMax = map[req.name] || -1;
         if (req.requiredRarity.bonus > currentMax) {
           map[req.name] = req.requiredRarity.bonus;
         }
      });
    });
    return map;
  }, [orders, mainlineOrder]);

  const satisfiableOrders = useMemo(() => {
    if (!isSubmitMode || selectedIndices.length === 0) return [];
    const selectedItems = selectedIndices.map(idx => inventory[idx]).filter(Boolean);
    const handGroups = {};
    selectedItems.forEach(item => {
      if (!handGroups[item.name]) handGroups[item.name] = [];
      handGroups[item.name].push(item);
    });
    Object.keys(handGroups).forEach(k => {
      handGroups[k].sort((a, b) => b.rarity.bonus - a.rarity.bonus);
    });

    const checkOrder = (order, idx, isMain) => {
        const tempHand = JSON.parse(JSON.stringify(handGroups));
        let isSatisfied = true;
        let totalSubmitBonus = 0;
        
        // æŠ€èƒ½ã€å¼ºè¿«ç—‡ã€‘ï¼šå…¨åŒç±»
        const allReqs = order.requirements;
        let isSameType = false;
        if (hasSkill('ocd') && allReqs.length > 1) {
            const firstPool = allReqs[0].poolId; // æ³¨æ„ï¼šç”Ÿæˆæ—¶éœ€å¸¦ä¸Š poolId
            isSameType = allReqs.every(r => r.poolId === firstPool);
        }

        for (const req of order.requirements) {
            const availableItems = tempHand[req.name];
            if (!availableItems || availableItems.length === 0) {
            isSatisfied = false;
            break;
            }
            const matchIndex = availableItems.findIndex(item => item.rarity.bonus >= req.requiredRarity.bonus);
            if (matchIndex === -1) {
            isSatisfied = false;
            break;
            }
            const matchedItem = availableItems[matchIndex];
            totalSubmitBonus += matchedItem.rarity.bonus;
            availableItems.splice(matchIndex, 1);
        }
        if (!isSatisfied) return null;
        
        // è®¡ç®—æœ€ç»ˆå¥–åŠ±
        let multiplier = 1 + totalSubmitBonus;
        if (isSameType) multiplier *= 2; // å¼ºè¿«ç—‡ç¿»å€

        // æŠ€èƒ½ã€è´«å›°æ•‘æµã€‘
        let extraGold = 0;
        if (hasSkill('poverty_relief') && gold < 5 && order.rewardType === 'gold') {
            extraGold = 10;
        }

        const finalReward = Math.ceil(order.baseReward * multiplier) + extraGold;
        return { index: idx, finalReward, rewardType: order.rewardType, isMainline: isMain, reqCount: order.requirements.length, requirements: order.requirements };
    };

    const results = [];
    orders.forEach((o, i) => {
        const res = checkOrder(o, i, false);
        if (res) results.push(res);
    });
    if (mainlineOrder) {
        const res = checkOrder(mainlineOrder, -1, true); 
        if (res) results.push(res);
    }

    return results;
  }, [isSubmitMode, selectedIndices, inventory, orders, mainlineOrder, gold, skills]); // Add gold, skills to deps

  const totalRecycleValue = useMemo(() => {
    if (!isRecycleMode || selectedIndices.length === 0) return 0;
    return selectedIndices.reduce((sum, idx) => {
      const item = inventory[idx];
      // æŠ€èƒ½ã€èµ„æºå›æ”¶ã€‘é€»è¾‘éœ€è¦çŸ¥é“èƒŒåŒ…æ»¡ä¸æ»¡ï¼Œè¿™é‡Œç®€åŒ–å¤„ç†ï¼Œåªç®—åŸºç¡€å€¼ï¼Œå…·ä½“é€»è¾‘åœ¨ handleConfirmRecycle
      return sum + (item ? item.rarity.recycleValue : 0);
    }, 0);
  }, [isRecycleMode, selectedIndices, inventory]);

  const selectedItemNames = useMemo(() => {
    if (!isSubmitMode) return [];
    return selectedIndices.map(idx => inventory[idx]?.name).filter(Boolean);
  }, [isSubmitMode, selectedIndices, inventory]);

  // --- é˜Ÿåˆ—å¤„ç† ---
  useEffect(() => {
    if (!pendingItem && pendingQueue.length > 0) {
      const nextItem = pendingQueue[0];
      setPendingQueue(prev => prev.slice(1)); 
      
      if (inventory.length < maxInventorySize) {
        setInventory(prev => [...prev, nextItem]);
      } else {
        setPendingItem(nextItem);
        setSelectedSlot(null);
      }
    }
  }, [pendingItem, pendingQueue, inventory.length, selectionMode, maxInventorySize]);

  const createItem = (pool, itemTemplate, affixKey = null) => {
    const rarity = rollRarity(config, affixKey, gold, hasSkill, skillState, currentStageConfig);
    return { 
      ...itemTemplate, 
      uid: Math.random().toString(36).substr(2, 9), 
      poolName: pool.name, 
      rarity: rarity, 
      sterile: affixKey === 'hardened' 
    };
  };

  const handleDraw = (pool) => {
    if (pendingItem || isSubmitMode || isRecycleMode || selectionMode || pendingQueue.length > 0) return;

    let finalCost = pool.cost;

    // æŠ€èƒ½ã€ç²¾æ‰“ç»†ç®—ã€‘ï¼šé‡‘å¸<10ï¼Œæ¶ˆè€—-2
    if (pool.currency === 'gold' && hasSkill('calculated') && gold < 10) {
        finalCost = Math.max(1, finalCost - 2);
    }

    // æŠ€èƒ½ã€è´µå®¾æŠ˜æ‰£ã€‘
    if (pool.currency === 'gold' && hasSkill('vip_discount') && (pool.affixKey === 'precise' || pool.affixKey === 'targeted')) {
        finalCost = Math.max(0, finalCost - 1);
    }

    if (pool.type === 'mainline') {
      if (tickets < finalCost) {
        showToast("å¥–åˆ¸ä¸è¶³ï¼", "error");
        return;
      }
      setTickets(prev => prev - finalCost);
      handleMainlineDraw(pool);
    } else {
      if (pool.affixKey === 'trade_in') {
        setSelectionMode({ type: 'trade_in', pool });
        return;
      }
      if (pool.affixKey === 'precise') {
        if (gold < finalCost) { showToast("é‡‘å¸ä¸è¶³ï¼", "error"); return; }
        setGold(prev => prev - finalCost);
        
        const candidates = [];
        let itemIndices = pool.items.map((_, i) => i);
        
        for(let i=0; i<2; i++) {
           if (itemIndices.length === 0) itemIndices = pool.items.map((_, i) => i); 
           const randArrIdx = Math.floor(Math.random() * itemIndices.length);
           const actualItemIdx = itemIndices[randArrIdx];
           itemIndices.splice(randArrIdx, 1); 
           const tpl = pool.items[actualItemIdx];
           candidates.push(createItem(pool, tpl, pool.affixKey));
        }
        setSelectionMode({ type: 'precise', pool, items: candidates });
        return;
      }
      if (pool.affixKey === 'targeted') {
        if (gold < finalCost) { showToast("é‡‘å¸ä¸è¶³ï¼", "error"); return; }
        setGold(prev => prev - finalCost);
        setSelectionMode({ type: 'targeted', pool, items: pool.items, cost: finalCost }); 
        return;
      }
      if (gold < finalCost) {
        showToast("é‡‘å¸ä¸è¶³ï¼", "error");
        return;
      }
      setGold(prev => prev - finalCost);
      handleNormalDraw(pool);
    }
  };

  const handleNormalDraw = (pool) => {
    setDrawCount(prev => prev + 1);
    
    let itemsToProcess = [];

    if (pool.affixKey === 'fragmented') {
      for(let i=0; i<3; i++) {
        const tpl = pool.items[Math.floor(Math.random() * pool.items.length)];
        itemsToProcess.push(createItem(pool, tpl, 'fragmented'));
      }
    } else {
      const tpl = pool.items[Math.floor(Math.random() * pool.items.length)];
      const newItem = createItem(pool, tpl, pool.affixKey);
      itemsToProcess.push(newItem);
    }

    // æŠ€èƒ½ã€è‡ªåŠ¨è¡¥è´§ã€‘ï¼šå¤šè·å¾—1ä¸ª
    if (skillState.nextDrawExtraItem) {
        const tpl = pool.items[Math.floor(Math.random() * pool.items.length)];
        const extraItem = createItem(pool, tpl, pool.affixKey);
        itemsToProcess.push(extraItem);
        // Reset state later
    }
    
    // æ›´æ–°æŠ€èƒ½çŠ¶æ€ (Consolation Prize, Turn Fortune, Auto Restock)
    const newSkillState = { ...skillState };
    newSkillState.nextDrawExtraItem = false;
    newSkillState.nextDrawGuaranteedRare = false;

    // æ£€æŸ¥ã€å®‰æ…°å¥–ã€‘è®¡æ•°
    let allCommon = true;
    itemsToProcess.forEach(item => {
        if (item.rarity.id !== 'common') allCommon = false;
    });

    if (allCommon) {
        newSkillState.consecutiveCommons += 1;
    } else {
        newSkillState.consecutiveCommons = 0;
    }

    if (hasSkill('consolation_prize') && newSkillState.consecutiveCommons >= 5) {
        newSkillState.nextDrawGuaranteedRare = true;
        newSkillState.consecutiveCommons = 0; // Triggered, reset count
        showToast("ã€å®‰æ…°å¥–ã€‘è§¦å‘ï¼šä¸‹ä¸€æ¬¡å¿…å®šç¨€æœ‰ï¼", "info");
    }

    setSkillState(newSkillState);
    handleIncomingItems(itemsToProcess);
    refreshPools();
  };

  const handleIncomingItems = (items) => {
    // æŠ€èƒ½ã€è°ˆåˆ¤ä¸“å®¶ã€‘ï¼šå²è¯—+ -> åˆ·æ–°æ¬¡æ•°+1
    if (hasSkill('negotiator')) {
        let triggered = false;
        items.forEach(item => {
            if (item.rarity.bonus >= 0.4) triggered = true; // Epic bonus is 0.4
        });
        if (triggered) {
            setOrders(prev => prev.map(o => ({...o, remainingRefreshes: o.remainingRefreshes + 1})));
            showToast("ã€è°ˆåˆ¤ä¸“å®¶ã€‘è§¦å‘ï¼šè®¢å•åˆ·æ–°æ¬¡æ•°+1");
        }
    }

    const queue = [...items];
    const freeSlots = maxInventorySize - inventory.length;
    
    const toAdd = queue.splice(0, freeSlots);
    if (toAdd.length > 0) {
      setInventory(prev => [...prev, ...toAdd]);
    }

    if (queue.length > 0) {
      setPendingQueue(prev => [...prev, ...queue]);
    }
  };

  const handleMainlineDraw = (pool) => {
    const mainlineRate = config.global.mainlineDropRate || 0.3;
    const isMainlineItem = Math.random() < mainlineRate;

    if (isMainlineItem) {
        const target = pool.targetItem;
        const mythicRarity = config.rarity.find(r => r.id === 'mythic');
        const newItem = {
            ...target,
            uid: Math.random().toString(36).substr(2, 9),
            poolName: pool.name,
            rarity: mythicRarity, 
            isMainlineItem: true
        };

        setModalContent({
            title: "ä¼ è¯´é™ä¸´ï¼",
            item: newItem,
            message: "è·å¾—äº†ç¨€æœ‰çš„ä¸»çº¿é“å…·ï¼",
            type: 'resource',
            actualItem: newItem
        });

    } else {
        const randomPool = config.pools[Math.floor(Math.random() * config.pools.length)];
        const randomItem = randomPool.items[Math.floor(Math.random() * randomPool.items.length)];
        
        // ä¿®æ­£ï¼šä¸»çº¿æ± å¡«å……ç‰©ç¨€æœ‰åº¦å›ºå®šæœºåˆ¶ (é˜¶æ®µ1=common, é˜¶æ®µ2=uncommon(green), é˜¶æ®µ3=rare(blue), é˜¶æ®µ4+=epic(purple))
        // ä½¿ç”¨ config.stages ä¸­çš„ id æ¥åˆ¤æ–­æ›´ç¨³å¥ï¼Œé˜²æ­¢æ•°ç»„é¡ºåºå˜åŠ¨
        const currentStageId = config.stages[mainlineProgress]?.id;

        let targetRarityId = 'common';
        if (currentStageId === 1) targetRarityId = 'uncommon'; // Stage 2: åˆè¯†ä»·å€¼ -> Green
        else if (currentStageId === 2) targetRarityId = 'rare'; // Stage 3: é£é™©å¼•å…¥ -> Blue
        else if (currentStageId >= 3) targetRarityId = 'epic'; // Stage 4+: ç­–ç•¥/å·…å³° -> Purple

        const rarity = config.rarity.find(r => r.id === targetRarityId) || config.rarity[0];

        const newItem = {
            ...randomItem,
            uid: Math.random().toString(36).substr(2, 9),
            poolName: randomPool.name,
            rarity: rarity
        };
        
        setModalContent({
            title: rarity.id === 'legendary' ? "é‡‘è‰²ä¼ è¯´ï¼" : (rarity.id === 'epic' ? "å²è¯—ç‰©å“" : "æ„å¤–æ”¶è·"),
            item: newItem,
            message: "æ¥è‡ªä¸»çº¿æ± çš„æ„å¤–æ”¶è·",
            type: 'normal',
            actualItem: newItem
        });
    }
  };

  const handleCloseModal = () => {
    if (modalContent?.type === 'stage_up') {
        // å…³é—­é˜¶æ®µæ™‹å‡å¼¹çª—åï¼Œè§¦å‘æŠ€èƒ½é€‰æ‹©
        setModalContent(null);
        triggerSkillSelection();
        return;
    }

    if (modalContent?.actualItem) {
      handleIncomingItems([modalContent.actualItem]);
    }
    setDrawCount(prev => prev + 1);
    refreshPools();
    setModalContent(null);
  };

  const handleSelectionSelect = (selectedItem) => {
    const { type, pool } = selectionMode;
    
    if (type === 'precise') {
      setDrawCount(prev => prev + 1);
      // ç²¾å‡†æŠ½å–ä¹Ÿå¯èƒ½è§¦å‘è‡ªåŠ¨è¡¥è´§ç­‰é€»è¾‘ï¼Œè¿™é‡Œç®€åŒ–å¤„ç†ï¼Œç›´æ¥è¿›èƒŒåŒ…
      handleIncomingItems([selectedItem]);
      refreshPools();
      setSelectionMode(null);
    } else if (type === 'targeted') {
      const newItem = createItem(pool, selectedItem, pool.affixKey);
      setDrawCount(prev => prev + 1);
      handleIncomingItems([newItem]);
      refreshPools();
      setSelectionMode(null);
    }
  };

  const handleSelectionCancel = () => {
    if (selectionMode?.type === 'targeted') {
      setGold(prev => prev + selectionMode.cost); // Refund calculated cost
      setSelectionMode(null);
    }
  }

  const handleSlotClick = (index) => {
    // Inventory logic
    if (selectionMode?.type === 'trade_in') {
      const consumedItem = inventory[index]; 
      if (!consumedItem) return;

      if (consumedItem.isMainlineItem) {
          showToast("ä¸»çº¿é“å…·æ— æ³•ç”¨äºä»¥æ—§æ¢æ–°ï¼", "error");
          return;
      }

      const pool = selectionMode.pool;
      const newInv = [...inventory];
      newInv.splice(index, 1);
      setInventory(newInv);
      
      let candidates = pool.items.filter(i => i.name !== consumedItem.name);
      if (candidates.length === 0) candidates = pool.items; 

      const tpl = candidates[Math.floor(Math.random() * candidates.length)];
      const rarityConfig = config.rarity;
      const oldRarityIndex = rarityConfig.findIndex(r => r.id === consumedItem.rarity.id);
      
      let newRarity;
      if (oldRarityIndex === -1) {
          newRarity = rarityConfig[0];
      } else {
          const isUpgrade = Math.random() < 0.05; 
          let newRarityIndex = oldRarityIndex;
          if (isUpgrade) {
              newRarityIndex = Math.min(rarityConfig.length - 1, oldRarityIndex + 1);
          }
          newRarity = rarityConfig[newRarityIndex];
      }

      const newItem = { 
        ...tpl, 
        uid: Math.random().toString(36).substr(2, 9), 
        poolName: pool.name, 
        rarity: newRarity,
        sterile: consumedItem.sterile 
      };
      
      setDrawCount(prev => prev + 1);
      handleIncomingItems([newItem]);
      // Trade In æ˜¯æŠ½å¥–è¡Œä¸ºï¼Œæ¶ˆè€—ç‰©å“è·å¾—æ–°ç‰©å“ï¼Œåº”è¯¥åˆ·æ–°æ± å­
      refreshPools();
      setSelectionMode(null);
      return;
    }

    if (isSubmitMode || isRecycleMode) {
      if (!inventory[index]) return;
      if (selectedIndices.includes(index)) {
        setSelectedIndices(prev => prev.filter(i => i !== index));
      } else {
        setSelectedIndices(prev => [...prev, index]);
      }
      return;
    }

    if (pendingItem) {
      const targetItem = inventory[index];
      // Merge
      if (targetItem && !targetItem.sterile && !pendingItem.sterile &&
          pendingItem.name === targetItem.name && 
          pendingItem.rarity.id === targetItem.rarity.id && 
          pendingItem.rarity.id !== 'mythic') {
        
        // é˜¶æ®µåˆæˆé”æ£€æŸ¥
        if (!currentStageConfig.mechanics.synthesis) {
            showToast("åˆæˆç³»ç»Ÿæš‚æœªè§£é”ï¼", "error");
            return;
        }

        const nextRarity = getNextRarity(targetItem.rarity.id, config);
        
        // æ–°å¢ï¼šæ£€æŸ¥ä¸‹ä¸€çº§å“è´¨åœ¨å½“å‰é˜¶æ®µæ˜¯å¦å…è®¸å­˜åœ¨ (weight > 0)
        // ä¿®æ­£ï¼š2025-11-25 ç¡®ä¿åˆæˆä¸è¶…å‡ºå½“å‰æ—¶ä»£é™åˆ¶
        if (currentStageConfig.rarityWeights[nextRarity.id] <= 0) {
            showToast(`å—é™äºå½“å‰æ—¶ä»£å·¥è‰ºï¼Œæ— æ³•åˆæˆã€${nextRarity.name}ã€‘ç‰©å“ï¼`, 'error');
            return;
        }

        const upgradedItem = { ...targetItem, rarity: nextRarity, uid: Math.random().toString(36).substr(2, 9) };
        const newInventory = [...inventory];
        newInventory[index] = upgradedItem;
        setInventory(newInventory);
        setPendingItem(null);
        return;
      }
      // Recycle replace
      const recycleGain = targetItem.rarity.recycleValue;
      if (recycleGain > 0) setGold(prev => prev + recycleGain);

      const newInventory = [...inventory];
      newInventory[index] = pendingItem; 
      setInventory(newInventory);
      setPendingItem(null);
      return;
    }

    if (selectedSlot === null) {
      if (inventory[index]) setSelectedSlot(index);
      return;
    }
    if (selectedSlot === index) {
      setSelectedSlot(null);
      return;
    }
    if (typeof selectedSlot === 'number') {
      const sourceItem = inventory[selectedSlot];
      const targetItem = inventory[index];

      // Merge on move
      if (targetItem && !targetItem.sterile && !sourceItem.sterile &&
          sourceItem.name === targetItem.name && 
          sourceItem.rarity.id === targetItem.rarity.id && 
          sourceItem.rarity.id !== 'mythic') {
        
        // é˜¶æ®µåˆæˆé”æ£€æŸ¥
        if (!currentStageConfig.mechanics.synthesis) {
            showToast("åˆæˆç³»ç»Ÿæš‚æœªè§£é”ï¼", "error");
            setSelectedSlot(null);
            return;
        }

        const nextRarity = getNextRarity(sourceItem.rarity.id, config);
        
        // æ–°å¢ï¼šæ£€æŸ¥ä¸‹ä¸€çº§å“è´¨åœ¨å½“å‰é˜¶æ®µæ˜¯å¦å…è®¸å­˜åœ¨ (weight > 0)
        if (currentStageConfig.rarityWeights[nextRarity.id] <= 0) {
             showToast(`å—é™äºå½“å‰æ—¶ä»£å·¥è‰ºï¼Œæ— æ³•åˆæˆã€${nextRarity.name}ã€‘ç‰©å“ï¼`, 'error');
             setSelectedSlot(null); // Deselect
             return;
        }

        const upgradedItem = { ...targetItem, rarity: nextRarity, uid: Math.random().toString(36).substr(2, 9) };
        const newInventory = [...inventory];
        newInventory[index] = upgradedItem;
        newInventory[selectedSlot] = null;
        setInventory(newInventory.filter(item => item !== null));
        setSelectedSlot(null);
        return;
      }
      // Swap
      if (targetItem) {
        const newInventory = [...inventory];
        newInventory[index] = sourceItem;
        newInventory[selectedSlot] = targetItem;
        setInventory(newInventory);
        setSelectedSlot(null);
        return;
      }
      // Move to empty
      const newInventory = [...inventory];
      const [movedItem] = newInventory.splice(selectedSlot, 1);
      newInventory.splice(index, 0, movedItem);
      setInventory(newInventory);
      setSelectedSlot(null);
    }
  };

  const handleDiscardNew = () => {
    const recycleGain = pendingItem.rarity.recycleValue;
    if (recycleGain > 0) setGold(prev => prev + recycleGain);
    setPendingItem(null);
    setSelectedSlot(null);
  };

  const handleRefreshAllOrders = () => {
    if (pendingItem || isSubmitMode || isRecycleMode || selectionMode) return;
    if (gold < config.global.refreshCost) return; 
    // å®‰å…¨æ£€æŸ¥ï¼šé˜²æ­¢æœªè§£é”æ—¶è°ƒç”¨
    if (!currentStageConfig.mechanics.refresh) {
         showToast("å½“å‰æ—¶ä»£å°šæœªè§£é”è®¢å•åˆ·æ–°æŠ€æœ¯ï¼", "error");
         return;
    }

    setGold(prev => prev - config.global.refreshCost); 
    setOrders(Array(currentStageConfig.orderSlots).fill(null).map(() => generateOrder(allNormalItems, config, hasSkill, currentStageConfig)));
  };

  const handleRefreshSingleOrder = (index) => {
    if (pendingItem || isSubmitMode || isRecycleMode || selectionMode) return;
    
    // å®‰å…¨æ£€æŸ¥
    if (!currentStageConfig.mechanics.refresh) {
         showToast("å½“å‰æ—¶ä»£å°šæœªè§£é”è®¢å•åˆ·æ–°æŠ€æœ¯ï¼", "error");
         return;
    }

    const currentOrder = orders[index];
    if (currentOrder.remainingRefreshes <= 0) return;
    
    const newOrder = generateOrder(allNormalItems, config, hasSkill, currentStageConfig);

    // æŠ€èƒ½ã€æ—¶é—´å†»ç»“ã€‘ï¼š20% æ¦‚ç‡ä¸æ¶ˆè€—æ¬¡æ•°
    let newRefreshes = currentOrder.remainingRefreshes - 1;
    if (hasSkill('time_freeze') && Math.random() < 0.20) {
        newRefreshes = currentOrder.remainingRefreshes;
        showToast("ã€æ—¶é—´å†»ç»“ã€‘è§¦å‘ï¼šåˆ·æ–°æ¬¡æ•°æœªæ¶ˆè€—ï¼");
    }
    newOrder.remainingRefreshes = newRefreshes; 
    
    const newOrders = [...orders];
    newOrders[index] = newOrder;
    setOrders(newOrders);
  };

  const handleOrderClick = (orderIndex, isMainline = false) => {
    if (!isSubmitMode) return;
    
    const order = isMainline ? mainlineOrder : orders[orderIndex];
    if (!order) return;

    const newSelectedIndices = [...selectedIndices];
    const tempSelectedIndices = [...newSelectedIndices]; 
    const indicesToAdd = [];
    const requirements = [...order.requirements];
    
    for (const req of requirements) {
        const existingMatchIndexInSelected = tempSelectedIndices.findIndex(idx => {
             const item = inventory[idx];
             return item && item.name === req.name && item.rarity.bonus >= req.requiredRarity.bonus;
        });

        if (existingMatchIndexInSelected !== -1) {
            tempSelectedIndices.splice(existingMatchIndexInSelected, 1);
            continue;
        }

        const currentlyUsedIndices = new Set([...selectedIndices, ...indicesToAdd]);
        const candidates = inventory
            .map((item, idx) => ({ item, idx }))
            .filter(({ item, idx }) => 
                item && 
                !currentlyUsedIndices.has(idx) && 
                item.name === req.name && 
                item.rarity.bonus >= req.requiredRarity.bonus
            );
        
        candidates.sort((a, b) => b.item.rarity.bonus - a.item.rarity.bonus);

        if (candidates.length > 0) {
            const match = candidates[0];
            indicesToAdd.push(match.idx);
        }
    }

    if (indicesToAdd.length > 0) {
        setSelectedIndices([...selectedIndices, ...indicesToAdd]);
    }
  };

  const handleConfirmSubmission = () => {
    if (satisfiableOrders.length === 0) {
      showToast("è¯·è‡³å°‘å®Œæˆä¸€ä¸ªä»»åŠ¡æ‰èƒ½æäº¤ï¼", "error");
      return;
    }

    let gainedGold = 0;
    let gainedTickets = 0;
    const newOrders = [...orders];
    const completedIndices = [];
    let mainlineCompleted = false;

    // æŠ€èƒ½çŠ¶æ€æ›´æ–°
    const nextSkillState = { ...skillState };

    satisfiableOrders.forEach(({ index, finalReward, rewardType, isMainline, reqCount, requirements }) => {
      if (rewardType === 'gold') gainedGold += finalReward;
      if (rewardType === 'ticket') gainedTickets += finalReward;
      
      // æŠ€èƒ½ã€å¤§è®¢å•ä¸“å®¶ã€‘ï¼šreqCount == 4 -> 10 tickets
      if (hasSkill('big_order_expert') && reqCount === 4) {
          gainedTickets += 10;
          showToast("ã€å¤§è®¢å•ä¸“å®¶ã€‘è§¦å‘ï¼š+10å¥–åˆ¸");
      }

      // æŠ€èƒ½ã€å›°éš¾è®¢å•ä¸“å®¶ã€‘ï¼šéœ€æ±‚æœ‰å²è¯—ä»¥ä¸Š -> 15 tickets
      if (hasSkill('hard_order_expert')) {
          const hasHardReq = requirements.some(req => req.requiredRarity.id === 'epic' || req.requiredRarity.id === 'legendary');
          if (hasHardReq) {
              gainedTickets += 15;
              showToast("ã€å›°éš¾è®¢å•ä¸“å®¶ã€‘è§¦å‘ï¼š+15å¥–åˆ¸");
          }
      }

      // æŠ€èƒ½ã€è‡ªåŠ¨è¡¥è´§ã€‘
      if (hasSkill('auto_restock')) nextSkillState.nextDrawExtraItem = true;
      // æŠ€èƒ½ã€æ—¶æ¥è¿è½¬ã€‘
      if (hasSkill('turn_fortune')) nextSkillState.nextDrawGuaranteedRare = true;

      if (isMainline) {
          mainlineCompleted = true;
      } else {
          completedIndices.push(index);
      }
    });

    setSkillState(nextSkillState);

    setGold(prev => prev + gainedGold);
    setTickets(prev => prev + gainedTickets);

    completedIndices.forEach(idx => {
      newOrders[idx] = generateOrder(allNormalItems, config, hasSkill, currentStageConfig);
    });
    setOrders(newOrders);

    if (mainlineCompleted) {
        const nextProgress = mainlineProgress + 1;
        setMainlineProgress(nextProgress);
        
        if (nextProgress >= 5) {
             setModalContent({
                title: "æ­å–œé€šå…³ï¼",
                item: { name: 'æ¸¸æˆèƒœåˆ©', icon: 'ğŸ†', rarity: { color: 'bg-yellow-500', name: 'VICTORY', starColor: 'text-yellow-200' } },
                message: "ä½ å·²ç»å®Œæˆäº†æ‰€æœ‰ä¸»çº¿æŒ‘æˆ˜ï¼",
                type: 'victory'
             });
        } else {
            // é˜¶æ®µæ™‹å‡å¼¹çª—
            const nextStage = config.stages[nextProgress]; // Update access
            setModalContent({
                type: 'stage_up',
                title: `é˜¶æ®µè§£é”: ${nextStage.name}`,
                desc: nextStage.desc,
                unlocks: nextStage.unlocks,
                item: { name: nextStage.name, icon: 'ğŸš€', rarity: { color: 'bg-blue-500', name: 'NEW STAGE', starColor: 'text-white' } }
            });
        }
    }

    const newInventory = inventory.filter((_, idx) => !selectedIndices.includes(idx));
    setInventory(newInventory);

    setIsSubmitMode(false);
    setSelectedIndices([]);
  };

  const handleConfirmRecycle = () => {
    if (selectedIndices.length === 0) return;
    
    let baseValue = totalRecycleValue;
    let extraTickets = 0;

    // æŠ€èƒ½ã€ç‚¼é‡‘æœ¯ã€‘
    if (hasSkill('alchemy')) {
        selectedIndices.forEach(idx => {
            const item = inventory[idx];
            if (item && item.rarity.bonus >= 0.2) { // Rare+
                if (Math.random() < 0.15) extraTickets += 5;
            }
        });
        if (extraTickets > 0) showToast(`ã€ç‚¼é‡‘æœ¯ã€‘è§¦å‘ï¼šè·å¾— ${extraTickets} å¼ å¥–åˆ¸ï¼`, 'info');
    }

    setGold(prev => prev + baseValue);
    setTickets(prev => prev + extraTickets);

    const newInventory = inventory.filter((_, idx) => !selectedIndices.includes(idx));
    setInventory(newInventory);
    setIsRecycleMode(false);
    setSelectedIndices([]);
    // å›æ”¶ä¸åˆ·æ–° activePools, ä¿æŒé™æ­¢
  };

  const toggleSubmitMode = () => {
    if (pendingItem || selectionMode) return;
    if (isSubmitMode) {
      setIsSubmitMode(false);
      setSelectedIndices([]);
    } else {
      setIsSubmitMode(true);
      setIsRecycleMode(false); 
      setSelectedSlot(null); 
    }
  };

  const toggleRecycleMode = () => {
    if (pendingItem || selectionMode) return;
    if (isRecycleMode) {
      setIsRecycleMode(false);
      setSelectedIndices([]);
    } else {
      setIsRecycleMode(true);
      setIsSubmitMode(false); 
      setSelectedSlot(null);
    }
  };

  // --- Render Functions (Updated to use <skill.Icon />) ---

  const renderInventorySlot = (idx, isPendingSlot = false) => {
    let item;
    if (isPendingSlot) {
        item = pendingItem;
    } else {
        item = inventory[idx];
    }

    const isPickedUp = selectedSlot === idx && !isPendingSlot;
    const isTarget = (!isPendingSlot && selectedSlot !== null && !isPickedUp) || (!isPendingSlot && pendingItem);
    
    const maxReqBonus = maxRequirementRarityMap[item?.name];
    const isNeeded = maxReqBonus !== undefined;
    const isMaxSatisfied = isNeeded && item && item.rarity.bonus >= maxReqBonus;

    const isMultiSelectMode = isSubmitMode || isRecycleMode;
    const isSelected = isMultiSelectMode && !isPendingSlot && selectedIndices.includes(idx);
    const isTradeInMode = selectionMode?.type === 'trade_in';
    const isHovered = hoveredSlotIndex === idx && !isPendingSlot;
    let actionType = null; 

    // Merge/Upgrade hint logic ...
    const canSynthesize = currentStageConfig.mechanics.synthesis;

    const showPassiveHint = canSynthesize && !isMultiSelectMode && !isTradeInMode && selectedSlot === null && item && !item.sterile && item.rarity.id !== 'mythic' && (
        (!isPendingSlot && (
            inventory.some((other, otherIdx) => otherIdx !== idx && other && !other.sterile && other.name === item.name && other.rarity.id === item.rarity.id) ||
            (pendingItem && !pendingItem.sterile && pendingItem.name === item.name && pendingItem.rarity.id === item.rarity.id)
        )) ||
        (isPendingSlot && inventory.some(invItem => invItem && !invItem.sterile && invItem.name === item.name && invItem.rarity.id === item.rarity.id))
    );

    if (!isMultiSelectMode && !isTradeInMode && isHovered && isTarget) {
      if (pendingItem) {
        if (canSynthesize && item && !item.sterile && !pendingItem.sterile && pendingItem.name === item.name && pendingItem.rarity.id === item.rarity.id && pendingItem.rarity.id !== 'mythic') {
          actionType = 'synthesize'; 
        } else {
          actionType = 'replace'; 
        }
      } else if (typeof selectedSlot === 'number' && item) {
        const sourceItem = inventory[selectedSlot];
        if (canSynthesize && sourceItem.name === item.name && !sourceItem.sterile && !item.sterile && sourceItem.rarity.id === item.rarity.id && sourceItem.rarity.id !== 'mythic') {
          actionType = 'synthesize';
        } else {
          actionType = 'swap';
        }
      } else if (selectedSlot !== null) {
        actionType = 'move';
      }
    }

    return (
      <button
        key={isPendingSlot ? 'pending' : idx}
        onClick={() => !isPendingSlot && handleSlotClick(idx)}
        disabled={(isMultiSelectMode && !item) || (isTradeInMode && (!item || item.isMainlineItem)) || isPendingSlot} 
        onMouseEnter={() => {
          if (item && !isPendingSlot) setHoveredItemName(item.name);
          if (!isPendingSlot) setHoveredSlotIndex(idx);
        }}
        onMouseLeave={() => {
          setHoveredItemName(null);
          setHoveredSlotIndex(null);
        }}
        className={`
          relative w-16 h-16 md:w-20 md:h-20 lg:w-24 lg:h-24 rounded-xl border-2 flex flex-col items-center justify-center gap-1
          transition-all duration-200 overflow-visible shrink-0
          ${item 
            ? `${item.rarity.color} ${item.rarity.shadow} shadow-sm` 
            : 'bg-slate-50 border-dashed border-slate-200'
          }
          ${!isMultiSelectMode && !isTradeInMode && isPickedUp ? '-translate-y-4 scale-110 z-10 shadow-xl ring-2 ring-blue-400' : ''}
          ${!isMultiSelectMode && !isTradeInMode && isTarget && pendingItem && !isPendingSlot ? 'animate-pulse ring-2 ring-red-400 cursor-pointer hover:bg-red-50' : ''}
          ${!isMultiSelectMode && !isTradeInMode && isTarget && !pendingItem && !isPendingSlot ? 'hover:border-blue-300 cursor-pointer' : ''}
          ${!isMultiSelectMode && actionType === 'synthesize' ? 'ring-4 ring-yellow-400 scale-105 z-20' : ''}
          ${!isMultiSelectMode && actionType === 'swap' ? 'hover:scale-105' : ''}

          ${isMultiSelectMode && item && !isPendingSlot ? 'cursor-pointer hover:scale-105' : ''}
          ${isSelected && isSubmitMode ? 'border-blue-600 bg-blue-50 border-2 z-10' : ''}
          ${isSelected && isRecycleMode ? 'border-amber-600 bg-amber-50 border-2 z-10' : ''}
          ${isMultiSelectMode && !isSelected && item && !isPendingSlot ? 'opacity-70 hover:opacity-100 grayscale-[0.3]' : ''}
        `}
      >
        {item && (
          <div className={`flex flex-col items-center justify-center w-full h-full ${item.sterile ? 'grayscale opacity-70' : ''}`}>
            <span className="text-2xl lg:text-3xl filter drop-shadow-sm">{item.icon}</span>
            <span className="text-[10px] font-bold leading-none truncate max-w-full px-1">{item.name}</span>
            {item.rarity.bonus > 0 && (
              <div className="absolute top-0 right-0 p-0.5 bg-white/50 rounded-bl-lg">
                <Star size={8} fill="currentColor" className={item.rarity.color.split(' ')[2]} />
              </div>
            )}
          </div>
        )}
        
        {item && item.sterile && (
          <div className="absolute bottom-0 left-0 p-0.5 bg-gray-800/80 rounded-tr-lg text-white z-10 text-[9px] px-1 font-bold">
            ç»è‚²çš„
          </div>
        )}

        {isSelected && (
            <div className={`absolute -top-2 -right-2 text-white rounded-full p-1 shadow-md z-20 animate-in zoom-in ${isRecycleMode ? 'bg-amber-600' : 'bg-blue-600'}`}>
              {isRecycleMode ? <Trash2 size={16}/> : <Check size={16} strokeWidth={4} />}
            </div>
        )}

        {item && isNeeded && (
          <div className={`absolute -bottom-1 -right-1 text-white rounded-full p-0.5 shadow-md border border-white z-10 ${isMaxSatisfied ? 'bg-green-500' : 'bg-slate-400'}`}>
              <Check size={14} strokeWidth={4} />
          </div>
        )}

        {showPassiveHint && (
          <div className="absolute -top-1.5 -left-1.5 bg-white text-yellow-600 rounded-full p-[2px] shadow-sm border border-yellow-200 z-10 animate-bounce">
              <ChevronsUp size={18} strokeWidth={4} />
          </div>
        )}
        
        {!isMultiSelectMode && !isTradeInMode && actionType === 'replace' && (
          <div className="absolute inset-0 flex items-center justify-center bg-red-500/90 rounded-lg transition-opacity z-10 animate-in fade-in">
            <div className="flex flex-col items-center text-white">
               <ArrowLeftRight size={24} />
               <span className="text-xs font-bold">å›æ”¶+{item?.rarity.recycleValue}</span>
            </div>
          </div>
        )}
        {!isMultiSelectMode && !isTradeInMode && actionType === 'synthesize' && (
          <div className="absolute inset-0 flex flex-col items-center justify-center bg-yellow-400/80 rounded-lg transition-opacity z-10 backdrop-blur-[1px] animate-pulse">
             <ChevronsUp size={36} className="text-white drop-shadow-md" />
             <span className="text-white text-xs font-black uppercase tracking-wider">å‡çº§</span>
          </div>
        )}
        {!isMultiSelectMode && !isTradeInMode && actionType === 'swap' && (
          <div className="absolute inset-0 flex items-center justify-center bg-blue-500/40 rounded-lg transition-opacity z-10 backdrop-blur-[1px]">
             <ArrowLeftRight size={32} className="text-white drop-shadow-md" />
          </div>
        )}
      </button>
    );
  };

  const renderOrderCard = (order, idx, isMainline = false) => {
      const satisfiedInfo = satisfiableOrders.find(so => so.isMainline === isMainline && so.index === (isMainline ? -1 : idx));
      const isWillComplete = !!satisfiedInfo;
      const finalReward = satisfiedInfo ? satisfiedInfo.finalReward : order.baseReward;
      const refreshEnabled = currentStageConfig.mechanics.refresh;

      return (
        <div 
        key={order.id} 
        onClick={() => handleOrderClick(idx, isMainline)}
        className={`relative w-full text-left group border-2 rounded-xl p-3 transition-all duration-300
            ${isMainline 
                ? 'border-purple-400 bg-purple-50 ring-2 ring-purple-200 shadow-md mb-4' 
                : 'border-white bg-white shadow-sm'
            }
            ${isWillComplete
                ? 'border-yellow-400 bg-yellow-50 shadow-md transform scale-[1.02] ring-2 ring-yellow-200' 
                : ''
            }
            ${isSubmitMode ? 'cursor-pointer hover:ring-2 hover:ring-blue-300' : 'cursor-default'}
            ${pendingItem ? 'opacity-50' : ''} 
        `}
        >
            {isMainline && (
                 <div className="absolute -top-3 left-3 bg-purple-600 text-white text-[10px] font-bold px-2 py-0.5 rounded-full shadow-sm flex items-center gap-1 z-20">
                    <Crown size={10} /> ä¸»çº¿ä»»åŠ¡ {mainlineProgress + 1}/5
                 </div>
            )}

            {!pendingItem && !isSubmitMode && !isRecycleMode && !selectionMode && !isMainline && refreshEnabled && (
                <div
                onClick={(e) => { e.stopPropagation(); handleRefreshSingleOrder(idx); }}
                className={`absolute top-2 right-2 z-20 w-8 h-8 flex items-center justify-center rounded-full transition-all duration-150
                    ${order.remainingRefreshes <= 0 
                        ? 'bg-slate-100 text-slate-300 cursor-not-allowed' 
                        : 'bg-orange-100 text-orange-600 shadow-md cursor-pointer hover:bg-orange-200 active:translate-y-1 active:shadow-none'
                    }
                `}
                title={`åˆ·æ–°è®¢å• (å‰©ä½™${order.remainingRefreshes}æ¬¡)`}
                >
                <RefreshCw size={14} /> 
                <span className="absolute -bottom-1 -right-1 bg-white text-[9px] font-black text-slate-600 px-1 rounded-full shadow-sm border border-slate-100 leading-none min-w-[14px] text-center">
                    {order.remainingRefreshes}
                </span>
                </div>
            )}
            
            <div className="flex justify-between items-start mb-2 mt-1">
                <div className="flex items-center gap-2">
                {isWillComplete ? (
                    <div className="flex items-center gap-1 animate-pulse">
                        {order.rewardType !== 'none' && (
                            <>
                             <span className="text-xs font-bold text-slate-400 line-through">{order.baseReward}</span>
                             <span className={`text-sm font-black px-2 py-0.5 rounded flex items-center gap-1 ${order.rewardType === 'gold' ? 'text-yellow-600 bg-yellow-100' : 'text-purple-600 bg-purple-100'}`}>
                               <Sparkles size={12}/> {finalReward} {order.rewardType === 'gold' ? <Coins size={12}/> : <Ticket size={12}/>}
                             </span>
                            </>
                        )}
                        {order.rewardType === 'none' && (
                             <span className="text-xs font-black text-purple-600 bg-purple-100 px-2 py-0.5 rounded flex items-center gap-1">
                                 <FastForward size={12} fill="currentColor" /> ä¸»çº¿è¿›åº¦ +1
                             </span>
                        )}
                    </div>
                ) : (
                    order.rewardType !== 'none' ? (
                        <span className={`text-xs font-bold px-2 py-0.5 rounded flex items-center gap-1
                        ${order.rewardType === 'gold' ? 'bg-yellow-400 text-yellow-900' : 'bg-purple-400 text-white'}
                        `}>
                        {order.baseReward} {order.rewardType === 'gold' ? <Coins size={12}/> : <Ticket size={12}/>}
                        </span>
                    ) : (
                        <span className="text-xs font-bold px-2 py-0.5 rounded bg-slate-100 text-slate-500 border border-slate-200">
                            å®Œæˆä»¥æ¨è¿›å‰§æƒ…
                        </span>
                    )
                )}
                </div>
            </div>
            
            <div className="flex flex-wrap gap-2 mb-2">
                {order.requirements.map((req, rIdx) => {
                let matchedItem = null;
                
                if (isSubmitMode) {
                    const selectedCandidates = selectedIndices
                        .map(idx => inventory[idx])
                        .filter(item => item && item.name === req.name);
                    if (selectedCandidates.length > 0) {
                        selectedCandidates.sort((a, b) => b.rarity.bonus - a.rarity.bonus);
                        matchedItem = selectedCandidates[0];
                    }
                }

                if (!matchedItem) {
                    const candidates = inventory.filter(i => i.name === req.name);
                    candidates.sort((a, b) => b.rarity.bonus - a.rarity.bonus);
                    matchedItem = candidates[0];
                }
                
                const hasItem = !!matchedItem;
                const isQualitySatisfied = matchedItem && matchedItem.rarity.bonus >= req.requiredRarity.bonus;
                const isSubmitted = isSubmitMode && selectedItemNames.includes(req.name); 
                
                // ä¿®æ­£ï¼šé«˜äº®é€»è¾‘åŠ å…¥ hoveredPoolItemNames æ£€æŸ¥
                // ä»…å½“ï¼š
                // 1. æœ‰å¥–æ± è¢«æ‚¬æµ®
                // 2. å¥–æ± IDåŒ¹é…
                // 3. ä¸æ˜¯ä¸»çº¿ç‰©å“éœ€æ±‚
                // 4. ä¸”è¯¥ç‰©å“åç§°ç¡®å®å­˜åœ¨äºå½“å‰è¢«æˆªæ–­çš„å¥–æ± ä¸­
                const isPoolHighlighted = hoveredPoolId && req.poolId === hoveredPoolId && !req.isMainlineItem && hoveredPoolItemNames.includes(req.name);
                const isItemHighlighted = hoveredItemName && req.name === hoveredItemName;
                const borderStyle = hasItem ? 'border-solid' : 'border-dashed';
                let bgColorClass = 'bg-slate-50';
                let iconFilterClass = 'grayscale opacity-50';
                let textColorClass = 'text-slate-400';
                
                if (hasItem && isQualitySatisfied) {
                    bgColorClass = matchedItem.rarity.color; 
                    iconFilterClass = ''; 
                    textColorClass = 'text-slate-700';
                } else if (hasItem && !isQualitySatisfied) {
                    bgColorClass = 'bg-slate-50'; 
                    iconFilterClass = 'grayscale opacity-50'; 
                    textColorClass = 'text-slate-500';
                }

                const borderColorClass = hasItem ? matchedItem.rarity.color.split(' ')[0] : 'border-slate-300';

                return (
                    <div key={rIdx} className={`
                        relative flex items-center gap-1 text-sm border-2 rounded px-2 py-1 transition-all duration-200
                        ${borderStyle} ${borderColorClass} ${bgColorClass} ${textColorClass}
                        ${isSubmitted ? 'ring-2 ring-blue-500 shadow-md transform scale-105' : ''}
                        ${(isPoolHighlighted || isItemHighlighted) && !isSubmitMode ? 'scale-110 z-30 shadow-xl' : ''}
                    `}>
                    <div className={`w-2 h-2 rounded-full ${req.requiredRarity.dotColor} shadow-sm border border-white/50 shrink-0`} title={`éœ€è¦: ${req.requiredRarity.name}`}></div>
                    <span className={`${iconFilterClass}`}>{req.icon}</span>
                    <span className={`font-bold ${iconFilterClass}`}>{req.name}</span>
                    {isSubmitted && isQualitySatisfied && (
                        <div className="absolute -top-2 -right-2 bg-blue-500 text-white rounded-full p-0.5 shadow">
                            <Check size={10} strokeWidth={4} />
                        </div>
                    )}
                    </div>
                );
                })}
            </div>
        </div>
      );
  };

  return (
    <div className="h-screen w-full bg-slate-50 text-slate-800 font-sans selection:bg-blue-100 overflow-hidden flex flex-col animate-in fade-in duration-500 relative">
      {toast && <Toast message={toast.message} type={toast.type} onClose={() => setToast(null)} />}
      
      {/* æŠ€èƒ½é€‰æ‹©å¼¹çª— */}
      {skillSelectionCandidates && (
          <SkillSelectionModal 
              candidates={skillSelectionCandidates} 
              onSelect={handleSkillSelect}
              currentSkills={skills}
              onReplace={handleSkillReplace}
          />
      )}

      <div className="w-full max-w-7xl mx-auto h-full flex flex-col shadow-2xl bg-white border-x border-slate-200 relative">
        
        <header className="p-4 bg-slate-800 text-white flex justify-between items-center shadow-md z-20 shrink-0">
          <div className="flex items-center gap-6">
            <div className="flex items-center gap-2 text-yellow-400">
              <Coins size={20} />
              <span className="text-xl font-bold">{gold}</span>
            </div>
            <div className="flex items-center gap-2 text-purple-300">
              <Ticket size={20} />
              <span className="text-xl font-bold">{tickets}</span>
            </div>
          </div>
          
          <div className="flex items-center gap-4">
             {/* Mainline Progress Indicator */}
             <div className="flex items-center gap-1 bg-slate-700/50 px-3 py-1 rounded-full border border-slate-600">
                <Flag size={14} className="text-purple-400"/>
                <span className="text-xs font-bold text-slate-300">{currentStageConfig.name}</span>
                <span className="text-sm font-black text-purple-200">{mainlineProgress}/5</span>
             </div>

            <div className="flex flex-col items-end">
              <span className="text-xs text-slate-400 font-bold uppercase tracking-wider">ç´¯è®¡æŠ½å¥–</span>
              <span className="text-xl font-bold">{drawCount} æ¬¡</span>
            </div>
            
            <div className="flex items-center gap-2 bg-slate-700 rounded-lg p-1">
               <button 
                  onClick={onReset}
                  title="é‡ç½®è¿›åº¦"
                  className="p-1.5 hover:bg-slate-600 rounded transition-colors text-red-300 hover:text-red-100"
                >
                  <Power size={20} />
                </button>
                <div className="w-[1px] h-5 bg-slate-600"></div>
                <button 
                  onClick={onOpenSettings}
                  title="é…ç½®æ¸¸æˆ"
                  className="p-1.5 hover:bg-slate-600 rounded transition-colors text-slate-300 hover:text-white"
                >
                  <Settings size={20} />
                </button>
            </div>
          </div>
        </header>

        <main className="flex-1 flex flex-col lg:flex-row overflow-hidden pb-[400px] lg:pb-[400px]">

          <section className={`
             flex-none lg:w-1/3 p-4 overflow-y-auto border-b lg:border-b-0 lg:border-r border-slate-200 bg-slate-50/50 transition-all
             ${selectionMode?.type === 'targeted' ? 'hidden md:block md:w-1/4' : ''}
          `}>
            <div className="flex justify-between items-center mb-4 sticky top-0 bg-slate-50/95 p-2 rounded-lg z-10 backdrop-blur-sm">
              <h2 className="text-sm font-bold text-slate-500 uppercase flex items-center gap-1">
                <Package size={16} /> å½“å‰è®¢å•
              </h2>
              {/* ä¿®æ”¹ï¼šåˆ·æ–°æŒ‰é’®æ ·å¼ä¼˜åŒ– & é˜¶æ®µé” */}
              <button 
                onClick={(e) => { e.stopPropagation(); handleRefreshAllOrders(); }}
                disabled={!!pendingItem || gold < config.global.refreshCost || isSubmitMode || isRecycleMode || !!selectionMode || !currentStageConfig.mechanics.refresh}
                className={`flex items-center gap-2 px-4 py-2 rounded-full font-bold transition-all duration-200 text-sm shadow-sm
                  ${pendingItem || gold < config.global.refreshCost || isSubmitMode || isRecycleMode || selectionMode || !currentStageConfig.mechanics.refresh
                    ? 'bg-slate-100 text-slate-400 cursor-not-allowed' 
                    : 'bg-orange-100 text-orange-700 hover:bg-orange-200 ring-1 ring-orange-300 hover:ring-2 hover:scale-105'}`}
              >
                {!currentStageConfig.mechanics.refresh ? <Lock size={14}/> : <RotateCcw size={14} />} 
                <span>{currentStageConfig.mechanics.refresh ? `åˆ·æ–°æ™®é€š (-${config.global.refreshCost})` : 'åˆ·æ–°æœªè§£é”'}</span> 
                {currentStageConfig.mechanics.refresh && <Coins size={12}/>}
              </button>
            </div>
            
            <div className="flex flex-col gap-3">
              {/* Render Mainline Order First */}
              {mainlineOrder && renderOrderCard(mainlineOrder, -1, true)}

              {/* Render Normal Orders */}
              {orders.map((order, idx) => renderOrderCard(order, idx, false))}
            </div>
          </section>

          <section className="flex-1 p-4 lg:p-8 flex flex-col overflow-y-auto relative">
             <div className="flex justify-between items-center mb-4">
              <h2 className="text-sm font-bold text-slate-500 uppercase flex items-center gap-1">
                <RefreshCw size={16} /> æŠ½å–ç‰©å“
              </h2>
              <span className="text-xs text-slate-400">ç‚¹å‡»å¡ç‰‡æŠ½å¥–</span>
            </div>
            
            <div className={`
                flex flex-col gap-4
                transition-opacity duration-300
                ${pendingItem || isSubmitMode || isRecycleMode || selectionMode ? 'opacity-30 pointer-events-none' : 'opacity-100'}
            `}>
              {activePools.map((pool) => {
                const relevantRequirements = pool.type === 'mainline' 
                    ? [] // ä¸»çº¿æ± ä¸æ˜¾ç¤ºæ™®é€šè®¢å•çš„éœ€æ±‚åŒ¹é…æç¤º
                    : orders.flatMap(o => o.requirements)
                        .filter(req => pool.items.some(poolItem => poolItem.name === req.name));
                
                let canAfford = false;
                let finalCost = pool.cost;
                // è®¡ç®—æŠ˜æ‰£åä»·æ ¼
                if (pool.currency === 'gold' && hasSkill('calculated') && gold < 10) {
                     finalCost = Math.max(1, finalCost - 2);
                }
                if (pool.currency === 'gold' && hasSkill('vip_discount') && (pool.affixKey === 'precise' || pool.affixKey === 'targeted')) {
                     finalCost = Math.max(0, finalCost - 1);
                }

                if (pool.type === 'mainline') {
                   canAfford = tickets >= finalCost;
                } else {
                   canAfford = pool.currency === 'gold' ? gold >= finalCost : tickets >= finalCost;
                }

                // 2025-11-25 åŠ¨æ€è®¡ç®—ä¸»çº¿æ± å¡«å……æ–‡æ¡ˆ
                // ä½¿ç”¨ Stage Id æ›´ç¨³å¥
                const currentStageId = config.stages[mainlineProgress]?.id;
                let fillerRarityName = 'æ™®é€š';
                if (currentStageId === 1) fillerRarityName = 'ä¼˜ç§€';
                else if (currentStageId === 2) fillerRarityName = 'ç¨€æœ‰';
                else if (currentStageId >= 3) fillerRarityName = 'å²è¯—';

                return (
                  <button
                    key={pool.id}
                    onClick={() => handleDraw(pool)}
                    onMouseEnter={() => {
                        if (pool.type !== 'mainline') {
                            setHoveredPoolId(pool.originalId || pool.id);
                            // ä¿®æ­£ï¼šæ‚¬æµ®æ—¶è®°å½•å½“å‰æ± å­å®ä¾‹å†…å®é™…å­˜åœ¨çš„ç‰©å“
                            setHoveredPoolItemNames(pool.items.map(i => i.name));
                        }
                    }}
                    onMouseLeave={() => {
                        setHoveredPoolId(null);
                        setHoveredPoolItemNames([]);
                    }}
                    disabled={!canAfford}
                    className={`
                      relative flex flex-row items-center rounded-2xl border-b-8 transition-transform active:scale-95 hover:brightness-95 hover:-translate-y-1
                      ${pool.color} p-4 md:p-6 min-h-[140px] text-left overflow-hidden
                      ${!canAfford ? 'opacity-50 grayscale cursor-not-allowed' : ''}
                    `}
                  >
                    <div className="absolute top-3 right-3 z-10 text-base font-black bg-white/95 text-slate-800 px-4 py-1.5 rounded-full shadow-lg border border-slate-100 flex items-center gap-1">
                         {finalCost === 0 ? 'å…è´¹' : finalCost} 
                         {pool.currency === 'gold' && <Coins size={14} className="fill-yellow-500 text-yellow-600"/>} 
                         {pool.currency === 'ticket' && <Ticket size={14} className="fill-purple-300 text-purple-600"/>}
                         {finalCost < pool.cost && (
                             <span className="text-[10px] text-red-500 line-through ml-1 opacity-60">{pool.cost}</span>
                         )}
                    </div>

                    <div className="flex flex-col items-center justify-center w-1/3 border-r border-black/10 pr-4 mr-4 shrink-0">
                      <span className="text-5xl lg:text-6xl filter drop-shadow-sm mb-2">{pool.icon}</span>
                      <span className="text-lg lg:text-xl font-black leading-tight tracking-tight">{pool.name}</span>
                    </div>

                    <div className="flex-1 flex flex-col justify-center h-full min-w-0">
                      {pool.type === 'mainline' ? (
                        <div className="flex flex-col gap-1 text-sm font-bold opacity-80 mt-6">
                           <p>ğŸ”¥ {(config.global.mainlineDropRate * 100).toFixed(0)}% ä¸»çº¿é“å…·: {pool.targetItem?.name}</p>
                           {/* åŠ¨æ€æ˜¾ç¤ºçš„å“è´¨æç¤º */}
                           <p>âœ¨ 90% éšæœº{fillerRarityName} / 10% éšæœºä¼ è¯´</p>
                           <p className="text-xs mt-1">é›†é½ä¸»çº¿é“å…·ä»¥é€šå…³æ¸¸æˆï¼</p>
                        </div>
                      ) : (
                        <div className="flex flex-col gap-2 mt-4">
                           {pool.affix && (
                             <div className="flex flex-col mb-2">
                                <div className="font-bold text-base flex items-center justify-between leading-tight">
                                   <span>{pool.affix.name}</span>
                                </div>
                                <div className="text-xs leading-snug text-slate-700 font-medium mt-1">{pool.affix.desc}</div>
                             </div>
                           )}
                           
                           {relevantRequirements.length > 0 ? (
                             <div className="flex flex-wrap gap-2 mt-1">
                               {relevantRequirements.map((req, i) => {
                                  let matchedItem = null;
                                  const candidates = inventory.filter(invItem => invItem.name === req.name);
                                  candidates.sort((a, b) => b.rarity.bonus - a.rarity.bonus);
                                  matchedItem = candidates[0];
                                  
                                  const hasItem = !!matchedItem;
                                  const isQualitySatisfied = matchedItem && matchedItem.rarity.bonus >= req.requiredRarity.bonus;

                                  const borderStyle = hasItem ? 'border-solid' : 'border-dashed';
                                  let bgColorClass = 'bg-white/80'; 
                                  let iconFilterClass = 'grayscale opacity-50';
                                  let textColorClass = 'text-slate-500';
                                  
                                  if (hasItem && isQualitySatisfied) {
                                      bgColorClass = 'bg-white'; 
                                      iconFilterClass = ''; 
                                      textColorClass = 'text-slate-800';
                                  } else if (hasItem && !isQualitySatisfied) {
                                      bgColorClass = 'bg-white/50';
                                      iconFilterClass = 'grayscale opacity-50';
                                      textColorClass = 'text-slate-500';
                                  }

                                  const borderColorClass = hasItem ? (matchedItem.rarity.color.split(' ')[0]) : 'border-slate-400/50';

                                  return (
                                    <div key={i} className={`relative flex items-center gap-1.5 px-2 py-1 rounded-lg text-xs font-bold border-2 shadow-sm ${borderStyle} ${borderColorClass} ${bgColorClass} ${textColorClass}`}>
                                      <div className={`w-2 h-2 rounded-full ${req.requiredRarity.dotColor} shadow-sm border border-white/50 shrink-0`}></div>
                                      <span className={`${iconFilterClass}`}>{req.icon}</span>
                                      <span className={`${iconFilterClass}`}>{req.name}</span>
                                      {hasItem && isQualitySatisfied && <div className="bg-green-500 text-white rounded-full p-[1px] ml-1"><Check size={8} strokeWidth={4} /></div>}
                                    </div>
                                  );
                               })}
                             </div>
                           ) : (
                               pool.items.length > 0 && !pool.type === 'mainline' && (
                                   <div className="flex flex-wrap gap-2 mt-1 opacity-50">
                                      {pool.items.slice(0, 3).map(item => (
                                          <div key={item.name} className="text-xs bg-black/5 px-2 py-1 rounded">{item.icon} {item.name}</div>
                                      ))}
                                      {pool.items.length > 3 && <span className="text-xs self-center">...</span>}
                                   </div>
                               )
                           )}
                        </div>
                      )}
                    </div>
                  </button>
                );
              })}
            </div>

            {selectionMode && selectionMode.type !== 'trade_in' && (
              <div className="absolute inset-0 bg-white/90 z-40 flex flex-col items-center justify-center p-4 animate-in fade-in">
                  <h3 className="text-xl font-bold text-center mb-6">
                    {selectionMode.type === 'precise' ? 'ç²¾å‡†æŠ½å–ï¼šäºŒé€‰ä¸€ (ä¸å¯å–æ¶ˆ)' : 'æœ‰çš„æ”¾çŸ¢ï¼šè¯·é€‰æ‹©ä½ æƒ³è¦çš„'}
                  </h3>
                  
                  <div className={`
                    grid gap-4 w-full max-w-2xl
                    ${selectionMode.type === 'precise' ? 'grid-cols-2' : 'grid-cols-3 md:grid-cols-5'}
                  `}>
                      {selectionMode.items.map((item, idx) => (
                        <button 
                          key={idx}
                          onClick={() => handleSelectionSelect(item)}
                          onMouseEnter={() => setHoveredItemName(item.name)}
                          onMouseLeave={() => setHoveredItemName(null)}
                          className={`
                             rounded-xl border-4 flex flex-col items-center justify-center gap-2 transition-all hover:scale-105 hover:shadow-lg aspect-square
                             ${item.rarity ? `${item.rarity.color} shadow-sm` : 'border-slate-200 bg-slate-50 hover:border-blue-400'}
                          `}
                        >
                          <span className="text-4xl">{item.icon}</span>
                          <span className="text-xs font-bold">{item.name}</span>
                          {item.rarity && (
                             <div className={`text-[10px] px-1 rounded ${item.rarity.color.split(' ')[2]} bg-white/50 font-bold`}>
                                {item.rarity.name}
                             </div>
                          )}
                        </button>
                      ))}
                  </div>

                  {selectionMode.type === 'targeted' && (
                    <button 
                       onClick={handleSelectionCancel}
                       className="mt-8 px-8 py-2 bg-slate-200 text-slate-600 font-bold rounded-full hover:bg-slate-300"
                    >
                      å–æ¶ˆ
                    </button>
                  )}
              </div>
            )}
          </section>

        </main>

        <footer className={`
            absolute bottom-0 w-full p-4 border-t-2 border-slate-200 bg-white/95 backdrop-blur shadow-[0_-8px_30px_rgba(0,0,0,0.1)] z-30 transition-colors duration-300 
            ${pendingItem ? 'bg-red-50/95 border-red-200' : ''}
            ${isSubmitMode ? 'bg-blue-50/95 border-blue-200' : ''}
            ${isRecycleMode ? 'bg-amber-50/95 border-amber-200' : ''}
            ${selectionMode?.type === 'trade_in' ? 'bg-purple-50/95 border-purple-200' : ''}
        `}>
          
          {/* æŠ€èƒ½æ  (New) */}
          <div className="flex items-center justify-center gap-4 mb-2 pb-2 border-b border-slate-100 relative">
             <div className="text-xs font-bold text-slate-400 uppercase tracking-widest absolute left-0 top-1/2 -translate-y-1/2 hidden md:block">è¢«åŠ¨æŠ€èƒ½</div>
             <div className="flex gap-4">
                 {[0, 1, 2].map(i => {
                     const skillId = skills[i];
                     const skill = SKILL_DEFINITIONS.find(s => s.id === skillId);
                     const SkillIcon = skill?.Icon || Zap;
                     return (
                         <div key={i} className="flex flex-col items-center gap-1">
                             <div className="group relative w-12 h-12 rounded-full border-2 border-slate-200 bg-slate-100 flex items-center justify-center transition-all hover:scale-110">
                                 {skill ? (
                                     <div className={`w-full h-full rounded-full flex items-center justify-center ${skill.color}`}>
                                         <SkillIcon size={18} />
                                         {/* Tooltip */}
                                         <div className="absolute bottom-full mb-2 bg-slate-800 text-white text-xs p-3 rounded-xl w-48 shadow-xl opacity-0 group-hover:opacity-100 transition-opacity pointer-events-none z-50 text-left">
                                             <div className="font-bold mb-1 flex items-center gap-2"><SkillIcon size={14} /> {skill.name}</div>
                                             <div className="opacity-90">{skill.desc}</div>
                                         </div>
                                     </div>
                                 ) : (
                                     <div className="text-slate-300"><Zap size={18} /></div>
                                 )}
                                 <div className="absolute -top-1 -right-1 text-[10px] bg-slate-300 text-white rounded-full w-4 h-4 flex items-center justify-center leading-none">{i+1}</div>
                             </div>
                             {/* æŠ€èƒ½åç§° */}
                             <span className="text-[10px] font-bold text-slate-500 max-w-[64px] truncate text-center leading-tight">
                                 {skill ? skill.name : 'ç©ºæ§½ä½'}
                             </span>
                         </div>
                     );
                 })}
             </div>
          </div>

          {/* ç¨€æœ‰åº¦åŠ æˆç¤ºæ„å›¾ (Restored) */}
          <div className="flex items-center justify-center gap-4 mb-2 pb-2 border-b border-slate-100 flex-wrap">
             {config.rarity.slice(1).map(rarity => {
               // é˜¶æ®µæœªå¼€æ”¾çš„ç¨€æœ‰åº¦ï¼Œæ˜¾ç¤ºä¸ºé”å®šæˆ–ä¸æ˜¾ç¤º
               const weights = currentStageConfig.rarityWeights;
               if (weights[rarity.id] === 0) return null;

               return (
               <div key={rarity.id} className="flex items-center gap-1.5 text-xs font-bold text-slate-500 bg-slate-50 px-2 py-1 rounded-full shadow-sm border border-slate-100 animate-in fade-in">
                  <Star size={12} fill="currentColor" className={rarity.starColor} />
                  <span>{rarity.name} +{Math.round(rarity.bonus * 100)}%</span>
               </div>
             )})}
          </div>

          <div className="flex justify-between items-center mb-2 px-2 max-w-3xl mx-auto">
            <h2 className="text-xs font-bold text-slate-400 uppercase tracking-wider">èƒŒåŒ…æ ä½ ({inventory.length}/{maxInventorySize})</h2>
            {selectedSlot !== null && !pendingItem && !isSubmitMode && !isRecycleMode && !selectionMode && (
               <span className="text-xs font-bold text-blue-500 animate-pulse bg-blue-50 px-2 py-1 rounded flex items-center gap-2">
                 <Hand size={14}/> æ•´ç†æ¨¡å¼
               </span>
            )}
            {isSubmitMode && (
               <span className="text-xs font-bold text-blue-600 animate-pulse flex items-center gap-1">
                 <Layers size={14}/> æäº¤æ¨¡å¼: ç‚¹å‡»è®¢å•å¡ç‰‡å¯ä¸€é”®é€‰æ‹©
               </span>
            )}
            {isRecycleMode && (
               <span className="text-xs font-bold text-amber-600 animate-pulse flex items-center gap-1">
                 <Trash2 size={14}/> å›æ”¶æ¨¡å¼: é€‰æ‹©é“å…·æ¢å–é‡‘å¸
               </span>
            )}
            {selectionMode?.type === 'trade_in' && (
               <span className="text-xs font-bold text-purple-600 animate-pulse flex items-center gap-1">
                 <Repeat size={14}/> ä»¥æ—§æ¢æ–°: è¯·ç‚¹å‡»é€‰æ‹©ä¸€ä¸ªç‰©å“æ¶ˆè€—
               </span>
            )}
          </div>

          <div className="absolute bottom-4 right-4 md:right-10 lg:right-20 flex gap-2 z-50">
             {!isSubmitMode && !isRecycleMode && !pendingItem && !selectionMode && (
               <>
                 <button onClick={toggleRecycleMode} className="flex items-center gap-2 bg-amber-100 text-amber-800 border border-amber-200 font-bold py-3 px-6 rounded-full shadow-lg hover:bg-amber-200 transition-transform active:scale-95">
                   <Trash2 size={18} /> å›æ”¶
                 </button>
                 <button onClick={toggleSubmitMode} className="flex items-center gap-2 bg-slate-800 text-white font-bold py-3 px-6 rounded-full shadow-xl hover:bg-slate-700 transition-transform active:scale-95">
                   <Layers size={18} /> å‡ºç‰Œ
                 </button>
               </>
             )}

             {isSubmitMode && (
               <>
                 <button onClick={toggleSubmitMode} className="bg-white border border-slate-300 text-slate-600 font-bold py-2 px-4 rounded-full shadow-sm hover:bg-slate-50">å–æ¶ˆ</button>
                 <button onClick={handleConfirmSubmission} disabled={selectedIndices.length === 0} className={`flex items-center gap-2 font-bold py-2 px-6 rounded-full shadow-lg ${selectedIndices.length > 0 ? 'bg-blue-600 text-white' : 'bg-slate-300 text-slate-500 cursor-not-allowed'}`}>
                   <Send size={16} /> ç¡®è®¤å‡ºç‰Œ
                 </button>
               </>
             )}

             {isRecycleMode && (
               <>
                 <button onClick={toggleRecycleMode} className="bg-white border border-slate-300 text-slate-600 font-bold py-2 px-4 rounded-full shadow-sm hover:bg-slate-50">å–æ¶ˆ</button>
                 <button onClick={handleConfirmRecycle} disabled={selectedIndices.length === 0} className={`flex items-center gap-2 font-bold py-2 px-6 rounded-full shadow-lg ${selectedIndices.length > 0 ? 'bg-amber-600 text-white' : 'bg-slate-300 text-slate-500 cursor-not-allowed'}`}>
                   <Trash2 size={16} /> ç¡®è®¤å›æ”¶ (+{totalRecycleValue}é‡‘å¸)
                 </button>
               </>
             )}
             
             {selectionMode?.type === 'trade_in' && (
                <button onClick={() => setSelectionMode(null)} className="bg-white border border-slate-300 text-slate-600 font-bold py-2 px-6 rounded-full shadow-sm hover:bg-slate-50">å–æ¶ˆ</button>
             )}
          </div>

          <div className="flex flex-col lg:flex-row gap-4 justify-center items-center lg:items-end relative max-w-3xl mx-auto">
             
             <div className="flex flex-wrap gap-2 justify-center max-w-full">
                {Array.from({ length: maxInventorySize }).map((_, i) => (
                  <div key={i} className="flex-shrink-0">
                    {renderInventorySlot(i)}
                  </div>
                ))}
             </div>

             {pendingItem && (
                <div className="absolute right-0 bottom-full mb-4 lg:mb-0 lg:static lg:bottom-auto flex flex-col items-end lg:items-start gap-2 animate-in slide-in-from-right-4 fade-in duration-300 z-40 max-w-full">
                  
                  <div className="bg-white/95 backdrop-blur-md p-3 rounded-2xl border-2 border-red-200 shadow-2xl flex flex-col gap-2 max-w-[95vw] lg:max-w-xl">
                      
                      <div className="flex justify-between items-center border-b border-red-100 pb-2">
                          <div className="flex items-center gap-2 text-red-600 font-bold text-sm">
                              <AlertCircle size={16} />
                              <span>èƒŒåŒ…å·²æ»¡ï¼å¾…å¤„ç†é˜Ÿåˆ— ({pendingQueue.length + 1})</span>
                          </div>
                          <div className="text-xs text-slate-400">
                              æŒ‰é¡ºåºå¤„ç†
                          </div>
                      </div>

                      <div className="flex items-start gap-3 overflow-x-auto pb-2 scrollbar-hide snap-x">
                          <div className="flex flex-col gap-2 shrink-0 snap-center items-center p-2 bg-red-50 rounded-xl border border-red-100 min-w-[100px]">
                              <div className="text-[10px] font-black text-red-500 bg-white px-2 py-0.5 rounded-full shadow-sm">å½“å‰å¤„ç†</div>
                              <div className="relative transform hover:scale-105 transition-transform">
                                   {renderInventorySlot(0, true)}
                              </div>
                              <button
                                  onClick={handleDiscardNew}
                                  className="w-full flex items-center justify-center gap-1 bg-white hover:bg-slate-50 border border-slate-200 text-slate-600 text-xs font-bold py-1.5 px-2 rounded-lg transition-colors shadow-sm"
                              >
                                  <X size={12} /> 
                                  {pendingItem.rarity.recycleValue > 0 ? `å›æ”¶ +${pendingItem.rarity.recycleValue}` : 'ä¸¢å¼ƒ'}
                              </button>
                          </div>

                          {pendingQueue.map((qItem, idx) => (
                              <div key={qItem.uid} className="flex flex-col gap-2 shrink-0 snap-center items-center opacity-60 grayscale-[0.3]">
                                  <div className="text-[10px] font-bold text-slate-400 mt-2">#{idx + 1}</div>
                                  <div className={`
                                      relative w-16 h-16 rounded-xl border-2 flex flex-col items-center justify-center gap-1 shadow-sm bg-slate-50
                                      ${qItem.rarity.color}
                                  `}>
                                      <span className="text-2xl filter drop-shadow-sm">{qItem.icon}</span>
                                      <span className="text-[9px] font-bold leading-none truncate max-w-full px-1">{qItem.name}</span>
                                      <div className="absolute top-1 right-1 w-2 h-2 rounded-full bg-white/50"></div>
                                  </div>
                              </div>
                          ))}
                          
                          {pendingQueue.length === 0 && (
                              <div className="h-full flex items-center justify-center px-4 text-xs text-slate-300 font-medium italic">
                                  é˜Ÿåˆ—ç©º
                              </div>
                          )}
                      </div>
                  </div>
                </div>
              )}

          </div>

        </footer>

        {modalContent && (
          <div className="fixed inset-0 z-[100] flex items-center justify-center bg-black/40 backdrop-blur-sm animate-in fade-in duration-200">
            <div className={`bg-white p-8 rounded-3xl shadow-2xl max-w-sm w-full flex flex-col items-center gap-4 text-center border-4 border-white transform scale-100 animate-in zoom-in-95 duration-200
               ${modalContent.type === 'victory' ? 'ring-4 ring-yellow-400 bg-yellow-50' : ''}
               ${modalContent.type === 'stage_up' ? 'ring-4 ring-blue-400 bg-blue-50' : ''}
               ${modalContent.type !== 'victory' && modalContent.type !== 'stage_up' ? 'ring-4 ring-purple-200' : ''}
            `}>
              <h3 className="text-2xl font-black text-slate-800">{modalContent.title}</h3>
              
              {modalContent.type === 'stage_up' ? (
                  <div className="flex flex-col items-center gap-4 py-4 w-full">
                      <div className="text-4xl animate-bounce">{modalContent.item.icon}</div>
                      <div className="w-full bg-white/50 rounded-xl p-4 border border-blue-200">
                          <h4 className="font-bold text-blue-800 mb-3 text-left">è§£é”æ–°å†…å®¹ï¼š</h4>
                          <ul className="text-left space-y-2">
                              {modalContent.unlocks.map((text, idx) => (
                                  <li key={idx} className="flex items-start gap-2 text-sm font-bold text-slate-600">
                                      <Check size={16} className="text-green-500 mt-0.5 shrink-0" />
                                      <span>{text}</span>
                                  </li>
                              ))}
                          </ul>
                      </div>
                      <button 
                        onClick={handleCloseModal}
                        className="mt-4 bg-blue-600 text-white font-bold py-3 px-12 rounded-full shadow-lg hover:bg-blue-700 transition-transform active:scale-95"
                      >
                        ç»§ç»­æŒ‘æˆ˜
                      </button>
                  </div>
              ) : (
                  <>
                    <div className={`w-32 h-32 rounded-2xl flex items-center justify-center text-6xl shadow-inner bg-slate-50 border-4 ${modalContent.item.rarity.color.split(' ')[0]}`}>
                        <div className={`flex flex-col items-center ${modalContent.item.sterile ? 'grayscale opacity-70' : ''}`}>
                        {modalContent.item.icon}
                        </div>
                    </div>
                    
                    <div className="flex flex-col gap-1">
                        <span className={`text-lg font-bold ${modalContent.item.rarity.starColor.replace('text-', 'text-')}`}>
                        {modalContent.item.rarity.name} {modalContent.item.name}
                        </span>
                        <p className="text-slate-500 font-medium">{modalContent.message}</p>
                    </div>

                    {modalContent.type === 'victory' ? (
                        <button 
                        onClick={() => window.location.reload()}
                        className="mt-4 bg-yellow-500 text-white font-bold py-3 px-8 rounded-full shadow-lg hover:bg-yellow-600 transition-transform active:scale-95 animate-pulse"
                        >
                        å†æ¥ä¸€å±€
                        </button>
                    ) : (
                        <button 
                        onClick={handleCloseModal}
                        className="mt-4 bg-slate-800 text-white font-bold py-3 px-8 rounded-full shadow-lg hover:bg-slate-700 transition-transform active:scale-95"
                        >
                        æ”¶ä¸‹
                        </button>
                    )}
                  </>
              )}
            </div>
          </div>
        )}

      </div>
    </div>
  );
}

export default function App() {
  const [config, setConfig] = useState(INITIAL_GAME_CONFIG);
  const [gameId, setGameId] = useState(0);
  const [showSettings, setShowSettings] = useState(false);
  const [resetConfirmOpen, setResetConfirmOpen] = useState(false);
  const [defaultResetConfirmOpen, setDefaultResetConfirmOpen] = useState(false);

  // Dev tools state
  const [devSkillsSelected, setDevSkillsSelected] = useState([]);
  const [initialSkills, setInitialSkills] = useState([]);

  const handleHardReset = () => {
    setGameId(prev => prev + 1);
    setInitialSkills([]); // Reset skills too
    setResetConfirmOpen(false);
  };

  const handleResetDefaults = () => {
    setConfig(INITIAL_GAME_CONFIG);
    setDefaultResetConfirmOpen(false);
  };

  const handleExportConfig = () => {
    const dataStr = JSON.stringify(config, null, 2);
    const blob = new Blob([dataStr], { type: "application/json" });
    const url = URL.createObjectURL(blob);
    const link = document.createElement("a");
    link.href = url;
    link.download = `order-game-config-${new Date().toISOString().slice(0,10)}.json`;
    link.click();
    URL.revokeObjectURL(url);
  };

  const handleImportConfig = (e) => {
    const file = e.target.files[0];
    if (!file) return;

    const reader = new FileReader();
    reader.onload = (event) => {
      try {
        const importedConfig = JSON.parse(event.target.result);
        if (importedConfig.rarity && importedConfig.pools && importedConfig.global && importedConfig.affixes) {
          setConfig(importedConfig);
        }
      } catch (err) {
        console.error(err);
      }
    };
    reader.readAsText(file);
    e.target.value = null;
  };

  return (
    <>
      <GameCore 
        key={gameId} 
        config={config} 
        initialSkills={initialSkills}
        onOpenSettings={() => setShowSettings(true)}
        onReset={() => setResetConfirmOpen(true)}
      />

      {resetConfirmOpen && (
        <ConfirmDialog 
          title="é‡æ–°å¼€å§‹æ¸¸æˆï¼Ÿ"
          message="ç¡®å®šè¦é‡æ–°å¼€å§‹æ¸¸æˆå—ï¼Ÿå½“å‰è¿›åº¦ï¼ˆé‡‘å¸ã€èƒŒåŒ…ã€æŠ€èƒ½ï¼‰å°†ä¸¢å¤±ã€‚"
          onConfirm={handleHardReset}
          onCancel={() => setResetConfirmOpen(false)}
        />
      )}
      
      {defaultResetConfirmOpen && (
        <ConfirmDialog 
          title="æ¢å¤é»˜è®¤é…ç½®ï¼Ÿ"
          message="ç¡®å®šè¦å°†æ‰€æœ‰é…ç½®å‚æ•°æ¢å¤ä¸ºé»˜è®¤å€¼å—ï¼Ÿæ­¤æ“ä½œä¸å¯æ’¤é”€ã€‚"
          onConfirm={handleResetDefaults}
          onCancel={() => setDefaultResetConfirmOpen(false)}
        />
      )}

      {showSettings && (
          <div className="fixed inset-0 z-[150] flex items-center justify-center bg-black/70 backdrop-blur-sm animate-in fade-in">
             <div className="bg-white rounded-2xl shadow-2xl w-full max-w-4xl h-[85vh] flex flex-col overflow-hidden">
                <div className="p-4 border-b flex justify-between items-center bg-slate-50">
                  <h3 className="text-xl font-black flex items-center gap-2 text-slate-700">
                    <Settings size={24} /> æ¸¸æˆé…ç½® & å¼€å‘è€…å·¥å…·
                  </h3>
                  <button onClick={() => setShowSettings(false)} className="p-2 hover:bg-slate-200 rounded-full">
                    <X size={24} />
                  </button>
                </div>
                
                <div className="flex-1 overflow-y-auto p-6 space-y-8">
                  {/* é˜¶æ®µå‚æ•°é…ç½® (æ–°å¢) */}
                  <section>
                    <h4 className="text-lg font-bold mb-4 border-l-4 border-emerald-500 pl-3">é˜¶æ®µç¨€æœ‰åº¦é…ç½® (æ¦‚ç‡: 0-1)</h4>
                    <div className="overflow-x-auto">
                        <table className="w-full text-sm">
                            <thead className="bg-slate-100 text-slate-500">
                                <tr>
                                    <th className="p-2 text-left">é˜¶æ®µåç§°</th>
                                    <th className="p-2 text-center w-20">æ™®é€š</th>
                                    <th className="p-2 text-center w-20">ä¼˜ç§€</th>
                                    <th className="p-2 text-center w-20">ç¨€æœ‰</th>
                                    <th className="p-2 text-center w-20">å²è¯—</th>
                                    <th className="p-2 text-center w-20">ä¼ è¯´</th>
                                </tr>
                            </thead>
                            <tbody>
                                {config.stages.map((stage, sIdx) => (
                                    <tr key={stage.id} className="border-b hover:bg-slate-50">
                                        <td className="p-2 font-bold">
                                            <div className="flex flex-col">
                                                <span>{stage.name}</span>
                                                <span className="text-[10px] text-slate-400 font-normal">{stage.desc}</span>
                                            </div>
                                        </td>
                                        {['common', 'uncommon', 'rare', 'epic', 'legendary'].map(rKey => (
                                            <td key={rKey} className="p-2 text-center">
                                                <input 
                                                    type="number"
                                                    step="0.05"
                                                    min="0" max="1"
                                                    className={`w-16 p-1 border rounded text-center font-mono ${stage.rarityWeights[rKey] > 0 ? 'bg-white font-bold' : 'bg-slate-50 text-slate-400'}`}
                                                    value={stage.rarityWeights[rKey]}
                                                    onChange={(e) => {
                                                        const val = parseFloat(e.target.value);
                                                        if (isNaN(val)) return;
                                                        const newStages = [...config.stages];
                                                        newStages[sIdx] = {
                                                            ...newStages[sIdx],
                                                            rarityWeights: {
                                                                ...newStages[sIdx].rarityWeights,
                                                                [rKey]: val
                                                            }
                                                        };
                                                        setConfig({ ...config, stages: newStages });
                                                    }}
                                                />
                                            </td>
                                        ))}
                                    </tr>
                                ))}
                            </tbody>
                        </table>
                    </div>
                  </section>

                  {/* æŠ€èƒ½é…ç½® */}
                   <section>
                    <h4 className="text-lg font-bold mb-4 border-l-4 border-indigo-500 pl-3">æŠ€èƒ½é…ç½® (å‹¾é€‰ä»¥å¯ç”¨æ‰è½)</h4>
                    <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-3">
                        {SKILL_DEFINITIONS.map(skill => (
                            <label key={skill.id} className="flex items-start gap-2 p-2 border rounded-lg hover:bg-slate-50 cursor-pointer">
                                <input 
                                    type="checkbox" 
                                    checked={config.enabledSkillIds?.includes(skill.id)}
                                    onChange={(e) => {
                                        const current = config.enabledSkillIds || [];
                                        let next;
                                        if (e.target.checked) next = [...current, skill.id];
                                        else next = current.filter(id => id !== skill.id);
                                        setConfig({ ...config, enabledSkillIds: next });
                                    }}
                                    className="mt-1"
                                />
                                <div className="text-sm">
                                    <div className="font-bold flex items-center gap-1"><skill.Icon size={14} /> {skill.name}</div>
                                    <div className="text-xs text-slate-500">{skill.desc}</div>
                                </div>
                            </label>
                        ))}
                    </div>
                  </section>

                   {/* å¼€å‘è€…å·¥å…·ï¼šç›´æ¥æ·»åŠ æŠ€èƒ½ (æ–°ç‰ˆå¤šé€‰) */}
                   <section>
                    <h4 className="text-lg font-bold mb-4 border-l-4 border-red-500 pl-3">å¼€å‘è€…å·¥å…·: ç›´æ¥è·å–æŠ€èƒ½ (å®æ—¶ç”Ÿæ•ˆ)</h4>
                    <div className="flex flex-col gap-3">
                        <div className="grid grid-cols-2 md:grid-cols-4 gap-2 max-h-48 overflow-y-auto p-2 border rounded-lg bg-slate-50">
                            {SKILL_DEFINITIONS.map(s => {
                                const isSelected = devSkillsSelected.includes(s.id);
                                return (
                                    <button
                                        key={s.id}
                                        onClick={() => {
                                            setDevSkillsSelected(prev => 
                                                prev.includes(s.id) ? prev.filter(id => id !== s.id) : [...prev, s.id]
                                            );
                                        }}
                                        className={`
                                            text-xs p-2 rounded border flex items-center gap-2 transition-all
                                            ${isSelected ? 'bg-red-100 border-red-400 text-red-800 ring-1 ring-red-400' : 'bg-white border-slate-200 text-slate-600 hover:bg-white'}
                                        `}
                                    >
                                        <s.Icon size={14} />
                                        <span className="font-bold truncate">{s.name}</span>
                                    </button>
                                )
                            })}
                        </div>
                        <div className="flex gap-2">
                            <button 
                                onClick={() => {
                                    if (devSkillsSelected.length > 0) {
                                        setInitialSkills(devSkillsSelected); // ç›´æ¥è¦†ç›–æ¨¡å¼
                                        setDevSkillsSelected([]); 
                                    }
                                }}
                                disabled={devSkillsSelected.length === 0}
                                className={`
                                    px-4 py-2 rounded-lg font-bold text-sm shadow transition-all
                                    ${devSkillsSelected.length > 0 ? 'bg-red-600 text-white hover:bg-red-700' : 'bg-slate-200 text-slate-400 cursor-not-allowed'}
                                `}
                            >
                                è¦†ç›–å½“å‰æ‰€æœ‰æŠ€èƒ½ ({devSkillsSelected.length}) - ä¸é‡å¯
                            </button>
                            <button 
                                 onClick={() => setDevSkillsSelected([])}
                                 className="px-3 py-2 text-slate-500 hover:text-slate-800 text-sm underline"
                            >
                                æ¸…ç©ºé€‰æ‹©
                            </button>
                        </div>
                    </div>
                  </section>

                   {/* è¯ç¼€è®¾ç½® (æ¢å¤) */}
                   <section>
                    <h4 className="text-lg font-bold mb-4 border-l-4 border-orange-500 pl-3">è¯ç¼€å‚æ•°é…ç½®</h4>
                    <div className="overflow-x-auto">
                      <table className="w-full text-sm">
                        <thead className="bg-slate-100 text-slate-500">
                          <tr>
                             <th className="p-2 text-left">è¯ç¼€åç§°</th>
                             <th className="p-2 text-left">å‡ºç°æƒé‡</th>
                             <th className="p-2 text-left">é‡‘å¸æ¶ˆè€—</th>
                             <th className="p-2 text-left">æè¿°</th>
                          </tr>
                        </thead>
                        <tbody>
                          {config.affixes.map((affix, idx) => (
                            <tr key={affix.id} className="border-b">
                               <td className="p-2 font-bold">{affix.name}</td>
                               <td className="p-2">
                                  <input 
                                    type="number" 
                                    value={affix.weight}
                                    onChange={(e) => {
                                      const newAffixes = [...config.affixes];
                                      newAffixes[idx] = { ...affix, weight: parseInt(e.target.value) || 0 };
                                      setConfig({...config, affixes: newAffixes});
                                    }}
                                    className="border rounded w-20 px-1 py-0.5"
                                  />
                               </td>
                               <td className="p-2">
                                  <input 
                                    type="number" 
                                    value={affix.cost}
                                    onChange={(e) => {
                                      const newAffixes = [...config.affixes];
                                      newAffixes[idx] = { ...affix, cost: parseInt(e.target.value) || 0 };
                                      setConfig({...config, affixes: newAffixes});
                                    }}
                                    className="border rounded w-20 px-1 py-0.5"
                                  />
                               </td>
                               <td className="p-2">
                                  <input 
                                    type="text" 
                                    value={affix.desc}
                                    onChange={(e) => {
                                      const newAffixes = [...config.affixes];
                                      newAffixes[idx] = { ...affix, desc: e.target.value };
                                      setConfig({...config, affixes: newAffixes});
                                    }}
                                    className="border rounded w-full px-1 py-0.5 text-xs"
                                  />
                               </td>
                            </tr>
                          ))}
                        </tbody>
                      </table>
                    </div>
                  </section>

                  {/* å“è´¨è®¾ç½® (æ¢å¤) */}
                  <section>
                    <h4 className="text-lg font-bold mb-4 border-l-4 border-purple-500 pl-3">å“è´¨å‚æ•°</h4>
                    <div className="overflow-x-auto">
                      <table className="w-full text-sm">
                        <thead className="bg-slate-100 text-slate-500">
                          <tr>
                             <th className="p-2 text-left">å“è´¨åç§°</th>
                             <th className="p-2 text-left">åŸºç¡€æ¦‚ç‡ (0-1)</th>
                             <th className="p-2 text-left">åŠ æˆå€ç‡ (Bonus)</th>
                             <th className="p-2 text-left">å›æ”¶ä»·å€¼ (Gold)</th>
                          </tr>
                        </thead>
                        <tbody>
                          {config.rarity.map((r, idx) => (
                            <tr key={r.id} className="border-b">
                               <td className="p-2 font-bold">{r.name}</td>
                               <td className="p-2">
                                  <input 
                                    type="number" step="0.01" 
                                    value={r.prob}
                                    onChange={(e) => {
                                      const newRarity = [...config.rarity];
                                      newRarity[idx] = { ...r, prob: parseFloat(e.target.value) };
                                      setConfig({...config, rarity: newRarity});
                                    }}
                                    className="border rounded w-20 px-1 py-0.5"
                                  />
                               </td>
                               <td className="p-2">
                                  <input 
                                    type="number" step="0.1" 
                                    value={r.bonus}
                                    onChange={(e) => {
                                      const newRarity = [...config.rarity];
                                      newRarity[idx] = { ...r, bonus: parseFloat(e.target.value) };
                                      setConfig({...config, rarity: newRarity});
                                    }}
                                    className="border rounded w-20 px-1 py-0.5"
                                  />
                               </td>
                               <td className="p-2">
                                  <input 
                                    type="number" 
                                    value={r.recycleValue}
                                    onChange={(e) => {
                                      const newRarity = [...config.rarity];
                                      newRarity[idx] = { ...r, recycleValue: parseInt(e.target.value) };
                                      setConfig({...config, rarity: newRarity});
                                    }}
                                    className="border rounded w-20 px-1 py-0.5"
                                  />
                               </td>
                            </tr>
                          ))}
                        </tbody>
                      </table>
                    </div>
                  </section>

                  {/* å¥–æ± è®¾ç½® (æ¢å¤) */}
                  <section>
                    <h4 className="text-lg font-bold mb-4 border-l-4 border-green-500 pl-3">å¥–æ± æƒé‡</h4>
                    <div className="space-y-4">
                       <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                          {config.pools.map((pool, idx) => (
                             <div key={pool.id} className={`p-3 rounded-lg border flex items-center gap-3 ${pool.color}`}>
                                <span className="text-2xl">{pool.icon}</span>
                                <div className="flex-1">
                                   <div className="font-bold">{pool.name}</div>
                                   <div className="grid grid-cols-1 gap-2 mt-2">
                                      <div>
                                        <label className="text-[10px] uppercase font-bold opacity-70">æƒé‡</label>
                                        <input 
                                          type="number" value={pool.weight}
                                          onChange={(e) => {
                                            const newPools = [...config.pools];
                                            newPools[idx] = { ...pool, weight: parseInt(e.target.value) || 0 };
                                            setConfig({...config, pools: newPools});
                                          }}
                                          className="w-full text-xs p-1 rounded border-black/10 bg-white/50"
                                        />
                                      </div>
                                   </div>
                                </div>
                             </div>
                          ))}
                       </div>
                    </div>
                  </section>

                  {/* å…¨å±€è®¾ç½® */}
                  <section>
                    <h4 className="text-lg font-bold mb-4 border-l-4 border-blue-500 pl-3">å…¨å±€å‚æ•°</h4>
                    <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
                      <div className="flex flex-col gap-1">
                         <label className="text-xs font-bold text-slate-500">åˆ·æ–°è®¢å•æ¶ˆè€— (é‡‘å¸)</label>
                         <input 
                           type="number" 
                           value={config.global.refreshCost}
                           onChange={(e) => setConfig({...config, global: {...config.global, refreshCost: parseInt(e.target.value) || 0}})}
                           className="border rounded px-3 py-2 font-mono"
                         />
                      </div>
                      <div className="flex flex-col gap-1">
                         <label className="text-xs font-bold text-slate-500">åˆå§‹é‡‘å¸</label>
                         <input 
                           type="number" 
                           value={config.global.initialGold}
                           onChange={(e) => setConfig({...config, global: {...config.global, initialGold: parseInt(e.target.value) || 0}})}
                           className="border rounded px-3 py-2 font-mono"
                         />
                      </div>
                      <div className="flex flex-col gap-1">
                         <label className="text-xs font-bold text-slate-500">åˆå§‹å¥–åˆ¸</label>
                         <input 
                           type="number" 
                           value={config.global.initialTickets}
                           onChange={(e) => setConfig({...config, global: {...config.global, initialTickets: parseInt(e.target.value) || 0}})}
                           className="border rounded px-3 py-2 font-mono"
                         />
                      </div>
                      <div className="flex flex-col gap-1">
                         <label className="text-xs font-bold text-slate-500">ä¸»çº¿æ± å‡ºç°æ¦‚ç‡ (0-1)</label>
                         <input 
                           type="number" 
                           step="0.05"
                           min="0" max="1"
                           value={config.global.mainlineChance !== undefined ? config.global.mainlineChance : 0.5}
                           onChange={(e) => setConfig({...config, global: {...config.global, mainlineChance: parseFloat(e.target.value)}})}
                           className="border rounded px-3 py-2 font-mono"
                         />
                      </div>
                      <div className="flex flex-col gap-1">
                         <label className="text-xs font-bold text-slate-500">ä¸»çº¿é“å…·æ‰ç‡ (0-1)</label>
                         <input 
                           type="number" 
                           step="0.05"
                           min="0" max="1"
                           value={config.global.mainlineDropRate !== undefined ? config.global.mainlineDropRate : 0.3}
                           onChange={(e) => setConfig({...config, global: {...config.global, mainlineDropRate: parseFloat(e.target.value)}})}
                           className="border rounded px-3 py-2 font-mono"
                         />
                      </div>
                      <div className="flex flex-col gap-1">
                         <label className="text-xs font-bold text-slate-500">ä¸»çº¿å¡«å……ç‰©ä¼ è¯´æ¦‚ç‡ (0-1)</label>
                         <input 
                           type="number" 
                           step="0.05"
                           min="0" max="1"
                           value={config.global.mainlineFillerLegendaryRate !== undefined ? config.global.mainlineFillerLegendaryRate : 0.1}
                           onChange={(e) => setConfig({...config, global: {...config.global, mainlineFillerLegendaryRate: parseFloat(e.target.value)}})}
                           className="border rounded px-3 py-2 font-mono"
                         />
                      </div>
                    </div>
                  </section>
                  
                </div>

                <div className="p-4 bg-slate-100 border-t flex justify-between items-center">
                   <div className="flex gap-2">
                      <button 
                         onClick={() => setDefaultResetConfirmOpen(true)}
                         className="flex items-center gap-2 px-4 py-2 text-slate-600 hover:bg-white rounded-lg transition-colors font-bold text-sm"
                      >
                         <ResetIcon size={16} /> é‡ç½®é»˜è®¤
                      </button>
                   </div>
                   
                   <div className="flex gap-3">
                      <label className="flex items-center gap-2 px-4 py-2 bg-white border border-slate-300 text-slate-700 rounded-lg cursor-pointer hover:bg-slate-50 transition-colors font-bold shadow-sm">
                         <Upload size={18} />
                         <span>å¯¼å…¥é…ç½®</span>
                         <input type="file" accept=".json" onChange={handleImportConfig} className="hidden" />
                      </label>
                      
                      <button 
                         onClick={handleExportConfig}
                         className="flex items-center gap-2 px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 transition-colors font-bold shadow-lg"
                      >
                         <Download size={18} /> å¯¼å‡ºé…ç½®
                      </button>
                   </div>
                </div>
             </div>
          </div>
        )}
    </>
  );
}